using System.Collections.Concurrent;
using DotNext.Threading;

namespace MyMusic.Common.Utilities;

/// <summary>
/// Abstract base class for a background task scheduler that manages parallel task execution
/// with configurable concurrency and pause/resume capabilities.
///
/// NOTE: AI GENERATED by Claude Code
/// </summary>
public abstract class BackgroundTaskScheduler<TTask> : IDisposable
{
    private readonly SemaphoreSlim _semaphore = new(1, 1);
    private readonly ConcurrentDictionary<Guid, RunningTask> _runningTasks = new();
    private readonly CancellationTokenSource _cancellationTokenSource = new();
    private readonly AsyncManualResetEvent _stopBarrier = new(false);

    private int _maxParallelTasks;
    private bool _isPaused;
    private bool _isDisposed;

    /// <summary>
    /// Gets or sets the maximum number of tasks that can run in parallel.
    /// </summary>
    public int MaxParallelTasks
    {
        get => _maxParallelTasks;
        set
        {
            if (value <= 0)
                throw new ArgumentException("MaxParallelTasks must be greater than zero.", nameof(value));

            int oldValue = Interlocked.Exchange(ref _maxParallelTasks, value);

            // If we increased the limit, and we're not paused, try to schedule more tasks
            if (value > oldValue && !_isPaused)
            {
                _ = TryScheduleTasksAsync();
            }
        }
    }

    /// <summary>
    /// Gets whether the scheduler is currently paused.
    /// </summary>
    public bool IsPaused => _isPaused;

    /// <summary>
    /// Gets the current number of running tasks.
    /// </summary>
    public int RunningTaskCount => _runningTasks.Count;

    protected BackgroundTaskScheduler(int maxParallelTasks, bool paused = false)
    {
        if (maxParallelTasks <= 0)
            throw new ArgumentException("MaxParallelTasks must be greater than zero.", nameof(maxParallelTasks));

        _maxParallelTasks = maxParallelTasks;
        _isPaused = true;

        if (!paused)
        {
            Task.Run(async () => await ResumeAsync());
        }
    }

    /// <summary>
    /// Pauses the scheduler. Running tasks will continue, but no new tasks will be scheduled.
    /// </summary>
    public async Task PauseAsync()
    {
        await _semaphore.WaitAsync();
        try
        {
            if (_isPaused)
                return;

            _isPaused = true;

            // Pause all currently running tasks
            foreach (var running in _runningTasks.Values.ToList())
            {
                await SetTaskPausedAsync(running.Task, _cancellationTokenSource.Token);
            }
        }
        finally
        {
            _semaphore.Release();
        }
    }

    /// <summary>
    /// Resumes the scheduler and starts scheduling new tasks.
    /// </summary>
    public async Task ResumeAsync()
    {
        await _semaphore.WaitAsync();
        try
        {
            if (!_isPaused)
                return;

            _isPaused = false;

            // Resume all currently running tasks
            foreach (var running in _runningTasks.Values.ToList())
            {
                await SetTaskRunningAsync(running.Task, _cancellationTokenSource.Token);
            }
        }
        finally
        {
            _semaphore.Release();
        }

        // Try to schedule more tasks
        await TryScheduleTasksAsync();
    }

    public ValueTask WaitAsync()
    {
        return _stopBarrier.WaitAsync();
    }

    /// <summary>
    /// Attempts to schedule tasks up to the maximum parallel limit.
    /// </summary>
    public async Task TryScheduleTasksAsync()
    {
        if (_isDisposed || _isPaused || _cancellationTokenSource.Token.IsCancellationRequested)
        {
            return;
        }

        await _semaphore.WaitAsync(_cancellationTokenSource.Token);
        try
        {
            // Calculate how many tasks we can schedule
            int availableSlots = _maxParallelTasks - _runningTasks.Count;

            if (availableSlots <= 0)
            {
                return;
            }

            // Pull next tasks
            var tasksToSchedule = await PullNextTasksAsync(availableSlots, _cancellationTokenSource.Token);

            if (!tasksToSchedule.Any())
            {
                return;
            }

            // Schedule each task
            foreach (var task in tasksToSchedule.Take(availableSlots))
            {
                var taskId = Guid.NewGuid();
                var execution = ExecuteTaskAsync(taskId, task);
                _runningTasks.TryAdd(taskId, new RunningTask(task, execution));
            }
        }
        finally
        {
            _semaphore.Release();
        }
    }

    /// <summary>
    /// Executes a single task and handles its lifecycle.
    /// </summary>
    private async Task ExecuteTaskAsync(Guid taskId, TTask task)
    {
        try
        {
            // Mark task as running
            await SetTaskRunningAsync(task, _cancellationTokenSource.Token);

            // Execute the task
            await ExecuteTaskCoreAsync(task, _cancellationTokenSource.Token);

            // Mark task as finished successfully
            await SetTaskFinishedAsync(task, _cancellationTokenSource.Token);
        }
        catch (Exception ex)
        {
            // Mark task as failed
            await SetTaskFailedAsync(task, ex.Message, _cancellationTokenSource.Token);
        }
        finally
        {
            // Remove from running tasks
            _runningTasks.TryRemove(taskId, out _);

            // Try to schedule more tasks if we have available slots
            if (!_isPaused)
            {
                var availableSlots = _maxParallelTasks - _runningTasks.Count;
                if (availableSlots > 0)
                {
                    await TryScheduleTasksAsync();
                }
            }
        }
    }

    #region Abstract Methods

    /// <summary>
    /// Pulls the next N tasks to be executed.
    /// </summary>
    /// <param name="count">The maximum number of tasks to pull.</param>
    /// <param name="cancellationToken"></param>
    /// <returns>A list of tasks to execute, or null/empty if no tasks are available.</returns>
    protected abstract Task<List<TTask>> PullNextTasksAsync(int count, CancellationToken cancellationToken);

    /// <summary>
    /// Executes the core logic of a task.
    /// </summary>
    /// <param name="task">The task to execute.</param>
    /// <param name="cancellationToken">Cancellation token for task execution.</param>
    protected abstract Task ExecuteTaskCoreAsync(TTask task, CancellationToken cancellationToken);

    /// <summary>
    /// Called when a task is paused.
    /// </summary>
    /// <param name="task">The task that was paused</param>
    /// <param name="cancellationToken"></param>
    protected abstract Task SetTaskPausedAsync(TTask task, CancellationToken cancellationToken);

    /// <summary>
    /// Called when a task is started or resumed.
    /// </summary>
    /// <param name="task">The task that started running</param>
    /// <param name="cancellationToken"></param>
    protected abstract Task SetTaskRunningAsync(TTask task, CancellationToken cancellationToken);

    /// <summary>
    /// Called when a task fails.
    /// </summary>
    /// <param name="task">The task that failed</param>
    /// <param name="errorMessage">The error message describing the failure.</param>
    /// <param name="cancellationToken"></param>
    protected abstract Task SetTaskFailedAsync(TTask task, string errorMessage, CancellationToken cancellationToken);

    /// <summary>
    /// Called when a task finishes successfully.
    /// </summary>
    /// <param name="task">The task that finished execution</param>
    /// <param name="cancellationToken"></param>
    protected abstract Task SetTaskFinishedAsync(TTask task, CancellationToken cancellationToken);

    #endregion

    #region IDisposable

    public void Dispose()
    {
        Dispose(true);
        GC.SuppressFinalize(this);
    }

    protected void Dispose(bool disposing)
    {
        if (_isDisposed)
        {
            return;
        }

        if (disposing)
        {
            _cancellationTokenSource.Cancel();

            // Wait for all running tasks to complete
            Task.WhenAll(_runningTasks.Values.Select(r => r.Execution)).Wait(TimeSpan.FromSeconds(30));

            _cancellationTokenSource.Dispose();
            _semaphore.Dispose();

            _stopBarrier.Set(true);
            _stopBarrier.Dispose();
        }

        _isDisposed = true;
    }

    #endregion

    public record struct RunningTask(TTask Task, Task Execution);
}