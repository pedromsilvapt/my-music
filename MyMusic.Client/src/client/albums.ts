/**
 * Generated by orval v8.2.0 ðŸº
 * Do not edit manually.
 * MyMusic.Server | v1
 * OpenAPI spec version: 1.0.0
 */

import {faker} from "@faker-js/faker";
import type {
    DataTag,
    DefinedInitialDataOptions,
    DefinedUseQueryResult,
    InvalidateOptions,
    QueryClient,
    QueryFunction,
    QueryKey,
    UndefinedInitialDataOptions,
    UseQueryOptions,
    UseQueryResult,
} from "@tanstack/react-query";
import {useQuery} from "@tanstack/react-query";
import type {RequestHandlerOptions} from "msw";
import {HttpResponse, http} from "msw";

import type {GetAlbumResponse, ListAlbumsResponse} from "../model";

export type listAlbumsResponse200 = {
    data: ListAlbumsResponse;
    status: 200;
};

export type listAlbumsResponseSuccess = listAlbumsResponse200 & {
    headers: Headers;
};

export type listAlbumsResponse = listAlbumsResponseSuccess;

export const getListAlbumsUrl = () => {
    return `/api/albums`;
};

export const listAlbums = async (
    options?: RequestInit,
): Promise<listAlbumsResponse> => {
    const res = await fetch(getListAlbumsUrl(), {
        ...options,
        method: "GET",
    });

    const body = [204, 205, 304].includes(res.status) ? null : await res.text();

    const data: listAlbumsResponse["data"] = body ? JSON.parse(body) : {};
    return {
        data,
        status: res.status,
        headers: res.headers,
    } as listAlbumsResponse;
};

export const getListAlbumsQueryKey = () => {
    return ["api", "albums"] as const;
};

export const getListAlbumsQueryOptions = <
    TData = Awaited<ReturnType<typeof listAlbums>>,
    TError = unknown,
>(options?: {
    query?: Partial<
        UseQueryOptions<Awaited<ReturnType<typeof listAlbums>>, TError, TData>
    >;
    fetch?: RequestInit;
}) => {
    const {query: queryOptions, fetch: fetchOptions} = options ?? {};

    const queryKey = queryOptions?.queryKey ?? getListAlbumsQueryKey();

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listAlbums>>> = ({
                                                                                signal,
                                                                            }) => listAlbums({signal, ...fetchOptions});

    return {queryKey, queryFn, ...queryOptions} as UseQueryOptions<
        Awaited<ReturnType<typeof listAlbums>>,
        TError,
        TData
    > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ListAlbumsQueryResult = NonNullable<
    Awaited<ReturnType<typeof listAlbums>>
>;
export type ListAlbumsQueryError = unknown;

export function useListAlbums<
    TData = Awaited<ReturnType<typeof listAlbums>>,
    TError = unknown,
>(
    options: {
        query: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof listAlbums>>, TError, TData>
        > &
            Pick<
                DefinedInitialDataOptions<
                    Awaited<ReturnType<typeof listAlbums>>,
                    TError,
                    Awaited<ReturnType<typeof listAlbums>>
                >,
                "initialData"
            >;
        fetch?: RequestInit;
    },
    queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useListAlbums<
    TData = Awaited<ReturnType<typeof listAlbums>>,
    TError = unknown,
>(
    options?: {
        query?: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof listAlbums>>, TError, TData>
        > &
            Pick<
                UndefinedInitialDataOptions<
                    Awaited<ReturnType<typeof listAlbums>>,
                    TError,
                    Awaited<ReturnType<typeof listAlbums>>
                >,
                "initialData"
            >;
        fetch?: RequestInit;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useListAlbums<
    TData = Awaited<ReturnType<typeof listAlbums>>,
    TError = unknown,
>(
    options?: {
        query?: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof listAlbums>>, TError, TData>
        >;
        fetch?: RequestInit;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};

export function useListAlbums<
    TData = Awaited<ReturnType<typeof listAlbums>>,
    TError = unknown,
>(
    options?: {
        query?: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof listAlbums>>, TError, TData>
        >;
        fetch?: RequestInit;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
} {
    const queryOptions = getListAlbumsQueryOptions(options);

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<
        TData,
        TError
    > & { queryKey: DataTag<QueryKey, TData, TError> };

    return {...query, queryKey: queryOptions.queryKey};
}

export const invalidateListAlbums = async (
    queryClient: QueryClient,
    options?: InvalidateOptions,
): Promise<QueryClient> => {
    await queryClient.invalidateQueries(
        {queryKey: getListAlbumsQueryKey()},
        options,
    );

    return queryClient;
};

export type getAlbumResponse200 = {
    data: GetAlbumResponse;
    status: 200;
};

export type getAlbumResponseSuccess = getAlbumResponse200 & {
    headers: Headers;
};

export type getAlbumResponse = getAlbumResponseSuccess;

export const getGetAlbumUrl = (id: number) => {
    return `/api/albums/${id}`;
};

export const getAlbum = async (
    id: number,
    options?: RequestInit,
): Promise<getAlbumResponse> => {
    const res = await fetch(getGetAlbumUrl(id), {
        ...options,
        method: "GET",
    });

    const body = [204, 205, 304].includes(res.status) ? null : await res.text();

    const data: getAlbumResponse["data"] = body ? JSON.parse(body) : {};
    return {data, status: res.status, headers: res.headers} as getAlbumResponse;
};

export const getGetAlbumQueryKey = (id: number) => {
    return ["api", "albums", id] as const;
};

export const getGetAlbumQueryOptions = <
    TData = Awaited<ReturnType<typeof getAlbum>>,
    TError = unknown,
>(
    id: number,
    options?: {
        query?: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof getAlbum>>, TError, TData>
        >;
        fetch?: RequestInit;
    },
) => {
    const {query: queryOptions, fetch: fetchOptions} = options ?? {};

    const queryKey = queryOptions?.queryKey ?? getGetAlbumQueryKey(id);

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAlbum>>> = ({
                                                                              signal,
                                                                          }) => getAlbum(id, {signal, ...fetchOptions});

    return {
        queryKey,
        queryFn,
        enabled: !!id,
        ...queryOptions,
    } as UseQueryOptions<Awaited<ReturnType<typeof getAlbum>>, TError, TData> & {
        queryKey: DataTag<QueryKey, TData, TError>;
    };
};

export type GetAlbumQueryResult = NonNullable<
    Awaited<ReturnType<typeof getAlbum>>
>;
export type GetAlbumQueryError = unknown;

export function useGetAlbum<
    TData = Awaited<ReturnType<typeof getAlbum>>,
    TError = unknown,
>(
    id: number,
    options: {
        query: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof getAlbum>>, TError, TData>
        > &
            Pick<
                DefinedInitialDataOptions<
                    Awaited<ReturnType<typeof getAlbum>>,
                    TError,
                    Awaited<ReturnType<typeof getAlbum>>
                >,
                "initialData"
            >;
        fetch?: RequestInit;
    },
    queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetAlbum<
    TData = Awaited<ReturnType<typeof getAlbum>>,
    TError = unknown,
>(
    id: number,
    options?: {
        query?: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof getAlbum>>, TError, TData>
        > &
            Pick<
                UndefinedInitialDataOptions<
                    Awaited<ReturnType<typeof getAlbum>>,
                    TError,
                    Awaited<ReturnType<typeof getAlbum>>
                >,
                "initialData"
            >;
        fetch?: RequestInit;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetAlbum<
    TData = Awaited<ReturnType<typeof getAlbum>>,
    TError = unknown,
>(
    id: number,
    options?: {
        query?: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof getAlbum>>, TError, TData>
        >;
        fetch?: RequestInit;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetAlbum<
    TData = Awaited<ReturnType<typeof getAlbum>>,
    TError = unknown,
>(
    id: number,
    options?: {
        query?: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof getAlbum>>, TError, TData>
        >;
        fetch?: RequestInit;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
} {
    const queryOptions = getGetAlbumQueryOptions(id, options);

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<
        TData,
        TError
    > & { queryKey: DataTag<QueryKey, TData, TError> };

    return {...query, queryKey: queryOptions.queryKey};
}

export const invalidateGetAlbum = async (
    queryClient: QueryClient,
    id: number,
    options?: InvalidateOptions,
): Promise<QueryClient> => {
    await queryClient.invalidateQueries(
        {queryKey: getGetAlbumQueryKey(id)},
        options,
    );

    return queryClient;
};

export const getListAlbumsResponseMock = (
    overrideResponse: Partial<ListAlbumsResponse> = {},
): ListAlbumsResponse => ({
    albums: Array.from(
        {length: faker.number.int({min: 1, max: 10})},
        (_, i) => i + 1,
    ).map(() => ({
        id: faker.number.int({min: undefined, max: undefined}),
        cover: faker.helpers.arrayElement([
            faker.helpers.arrayElement([
                faker.number.int({min: undefined, max: undefined}),
                null,
            ]),
            null,
        ]),
        name: faker.string.alpha({length: {min: 10, max: 20}}),
        year: faker.helpers.arrayElement([
            faker.helpers.arrayElement([
                faker.number.int({min: undefined, max: undefined}),
                null,
            ]),
            null,
        ]),
        songsCount: faker.helpers.arrayElement([
            faker.helpers.arrayElement([
                faker.number.int({min: undefined, max: undefined}),
                null,
            ]),
            null,
        ]),
        createdAt: faker.date.past().toISOString().slice(0, 19) + "Z",
    })),
    ...overrideResponse,
});

export const getGetAlbumResponseMock = (
    overrideResponse: Partial<GetAlbumResponse> = {},
): GetAlbumResponse => ({
    album: {
        id: faker.number.int({min: undefined, max: undefined}),
        cover: faker.helpers.arrayElement([
            faker.helpers.arrayElement([
                faker.number.int({min: undefined, max: undefined}),
                null,
            ]),
            null,
        ]),
        name: faker.string.alpha({length: {min: 10, max: 20}}),
        year: faker.helpers.arrayElement([
            faker.helpers.arrayElement([
                faker.number.int({min: undefined, max: undefined}),
                null,
            ]),
            null,
        ]),
        artistId: faker.number.int({min: undefined, max: undefined}),
        artistName: faker.string.alpha({length: {min: 10, max: 20}}),
        songsCount: faker.number.int({min: undefined, max: undefined}),
        createdAt: faker.date.past().toISOString().slice(0, 19) + "Z",
        songs: Array.from(
            {length: faker.number.int({min: 1, max: 10})},
            (_, i) => i + 1,
        ).map(() => ({
            id: faker.number.int({min: undefined, max: undefined}),
            cover: faker.helpers.arrayElement([
                faker.helpers.arrayElement([
                    faker.number.int({min: undefined, max: undefined}),
                    null,
                ]),
                null,
            ]),
            title: faker.string.alpha({length: {min: 10, max: 20}}),
            artists: Array.from(
                {length: faker.number.int({min: 1, max: 10})},
                (_, i) => i + 1,
            ).map(() => ({
                id: faker.number.int({min: undefined, max: undefined}),
                name: faker.string.alpha({length: {min: 10, max: 20}}),
            })),
            album: {
                id: faker.number.int({min: undefined, max: undefined}),
                name: faker.string.alpha({length: {min: 10, max: 20}}),
            },
            genres: Array.from(
                {length: faker.number.int({min: 1, max: 10})},
                (_, i) => i + 1,
            ).map(() => ({
                id: faker.number.int({min: undefined, max: undefined}),
                name: faker.string.alpha({length: {min: 10, max: 20}}),
            })),
            year: faker.helpers.arrayElement([
                faker.helpers.arrayElement([
                    faker.number.int({min: undefined, max: undefined}),
                    null,
                ]),
                null,
            ]),
            duration: faker.string.alpha({length: {min: 10, max: 20}}),
            isFavorite: faker.datatype.boolean(),
            isExplicit: faker.datatype.boolean(),
        })),
    },
    ...overrideResponse,
});

export const getListAlbumsMockHandler = (
    overrideResponse?:
        | ListAlbumsResponse
        | ((
        info: Parameters<Parameters<typeof http.get>[1]>[0],
    ) => Promise<ListAlbumsResponse> | ListAlbumsResponse),
    options?: RequestHandlerOptions,
) => {
    return http.get(
        "*/albums",
        async (info) => {
            return new HttpResponse(
                overrideResponse !== undefined
                    ? typeof overrideResponse === "function"
                        ? await overrideResponse(info)
                        : overrideResponse
                    : getListAlbumsResponseMock(),
                {status: 200, headers: {"Content-Type": "text/plain"}},
            );
        },
        options,
    );
};

export const getGetAlbumMockHandler = (
    overrideResponse?:
        | GetAlbumResponse
        | ((
        info: Parameters<Parameters<typeof http.get>[1]>[0],
    ) => Promise<GetAlbumResponse> | GetAlbumResponse),
    options?: RequestHandlerOptions,
) => {
    return http.get(
        "*/albums/:id",
        async (info) => {
            return new HttpResponse(
                overrideResponse !== undefined
                    ? typeof overrideResponse === "function"
                        ? await overrideResponse(info)
                        : overrideResponse
                    : getGetAlbumResponseMock(),
                {status: 200, headers: {"Content-Type": "text/plain"}},
            );
        },
        options,
    );
};
export const getAlbumsMock = () => [
    getListAlbumsMockHandler(),
    getGetAlbumMockHandler(),
];
