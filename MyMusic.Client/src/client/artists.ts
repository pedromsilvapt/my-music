/**
 * Generated by orval v8.2.0 ðŸº
 * Do not edit manually.
 * MyMusic.Server | v1
 * OpenAPI spec version: 1.0.0
 */

import {faker} from "@faker-js/faker";
import type {
    DataTag,
    DefinedInitialDataOptions,
    DefinedUseQueryResult,
    InvalidateOptions,
    QueryClient,
    QueryFunction,
    QueryKey,
    UndefinedInitialDataOptions,
    UseQueryOptions,
    UseQueryResult,
} from "@tanstack/react-query";
import {useQuery} from "@tanstack/react-query";
import type {RequestHandlerOptions} from "msw";
import {http, HttpResponse} from "msw";
import type {
    FilterMetadataResponse,
    FilterValuesResponse,
    GetArtistFilterValuesParams,
    GetArtistParams,
    GetArtistResponse,
    ListArtistsParams,
    ListArtistsResponse,
} from "../model";

export type listArtistsResponse200 = {
    data: ListArtistsResponse;
    status: 200;
};

export type listArtistsResponseSuccess = listArtistsResponse200 & {
    headers: Headers;
};

export type listArtistsResponse = listArtistsResponseSuccess;

export const getListArtistsUrl = (params?: ListArtistsParams) => {
    const normalizedParams = new URLSearchParams();

    Object.entries(params || {}).forEach(([key, value]) => {
        if (value !== undefined) {
            normalizedParams.append(key, value === null ? "null" : value.toString());
        }
    });

    const stringifiedParams = normalizedParams.toString();

    return stringifiedParams.length > 0
        ? `/api/artists?${stringifiedParams}`
        : `/api/artists`;
};

export const listArtists = async (
    params?: ListArtistsParams,
    options?: RequestInit,
): Promise<listArtistsResponse> => {
    const res = await fetch(getListArtistsUrl(params), {
        ...options,
        method: "GET",
    });

    const body = [204, 205, 304].includes(res.status) ? null : await res.text();

    const data: listArtistsResponse["data"] = body ? JSON.parse(body) : {};
    return {
        data,
        status: res.status,
        headers: res.headers,
    } as listArtistsResponse;
};

export const getListArtistsQueryKey = (params?: ListArtistsParams) => {
    return ["api", "artists", ...(params ? [params] : [])] as const;
};

export const getListArtistsQueryOptions = <
    TData = Awaited<ReturnType<typeof listArtists>>,
    TError = unknown,
>(
    params?: ListArtistsParams,
    options?: {
        query?: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof listArtists>>, TError, TData>
        >;
        fetch?: RequestInit;
    },
) => {
    const {query: queryOptions, fetch: fetchOptions} = options ?? {};

    const queryKey = queryOptions?.queryKey ?? getListArtistsQueryKey(params);

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listArtists>>> = ({
                                                                                 signal,
                                                                             }) => listArtists(params, {signal, ...fetchOptions});

    return {queryKey, queryFn, ...queryOptions} as UseQueryOptions<
        Awaited<ReturnType<typeof listArtists>>,
        TError,
        TData
    > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ListArtistsQueryResult = NonNullable<
    Awaited<ReturnType<typeof listArtists>>
>;
export type ListArtistsQueryError = unknown;

export function useListArtists<
    TData = Awaited<ReturnType<typeof listArtists>>,
    TError = unknown,
>(
    params: undefined | ListArtistsParams,
    options: {
        query: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof listArtists>>, TError, TData>
        > &
            Pick<
                DefinedInitialDataOptions<
                    Awaited<ReturnType<typeof listArtists>>,
                    TError,
                    Awaited<ReturnType<typeof listArtists>>
                >,
                "initialData"
            >;
        fetch?: RequestInit;
    },
    queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useListArtists<
    TData = Awaited<ReturnType<typeof listArtists>>,
    TError = unknown,
>(
    params?: ListArtistsParams,
    options?: {
        query?: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof listArtists>>, TError, TData>
        > &
            Pick<
                UndefinedInitialDataOptions<
                    Awaited<ReturnType<typeof listArtists>>,
                    TError,
                    Awaited<ReturnType<typeof listArtists>>
                >,
                "initialData"
            >;
        fetch?: RequestInit;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useListArtists<
    TData = Awaited<ReturnType<typeof listArtists>>,
    TError = unknown,
>(
    params?: ListArtistsParams,
    options?: {
        query?: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof listArtists>>, TError, TData>
        >;
        fetch?: RequestInit;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};

export function useListArtists<
    TData = Awaited<ReturnType<typeof listArtists>>,
    TError = unknown,
>(
    params?: ListArtistsParams,
    options?: {
        query?: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof listArtists>>, TError, TData>
        >;
        fetch?: RequestInit;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
} {
    const queryOptions = getListArtistsQueryOptions(params, options);

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<
        TData,
        TError
    > & { queryKey: DataTag<QueryKey, TData, TError> };

    return {...query, queryKey: queryOptions.queryKey};
}

export const invalidateListArtists = async (
    queryClient: QueryClient,
    params?: ListArtistsParams,
    options?: InvalidateOptions,
): Promise<QueryClient> => {
    await queryClient.invalidateQueries(
        {queryKey: getListArtistsQueryKey(params)},
        options,
    );

    return queryClient;
};

export type getArtistResponse200 = {
    data: GetArtistResponse;
    status: 200;
};

export type getArtistResponseSuccess = getArtistResponse200 & {
    headers: Headers;
};

export type getArtistResponse = getArtistResponseSuccess;

export const getGetArtistUrl = (id: number, params?: GetArtistParams) => {
    const normalizedParams = new URLSearchParams();

    Object.entries(params || {}).forEach(([key, value]) => {
        if (value !== undefined) {
            normalizedParams.append(key, value === null ? "null" : value.toString());
        }
    });

    const stringifiedParams = normalizedParams.toString();

    return stringifiedParams.length > 0
        ? `/api/artists/${id}?${stringifiedParams}`
        : `/api/artists/${id}`;
};

export const getArtist = async (
    id: number,
    params?: GetArtistParams,
    options?: RequestInit,
): Promise<getArtistResponse> => {
    const res = await fetch(getGetArtistUrl(id, params), {
        ...options,
        method: "GET",
    });

    const body = [204, 205, 304].includes(res.status) ? null : await res.text();

    const data: getArtistResponse["data"] = body ? JSON.parse(body) : {};
    return {
        data,
        status: res.status,
        headers: res.headers,
    } as getArtistResponse;
};

export const getGetArtistQueryKey = (id: number, params?: GetArtistParams) => {
    return ["api", "artists", id, ...(params ? [params] : [])] as const;
};

export const getGetArtistQueryOptions = <
    TData = Awaited<ReturnType<typeof getArtist>>,
    TError = unknown,
>(
    id: number,
    params?: GetArtistParams,
    options?: {
        query?: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof getArtist>>, TError, TData>
        >;
        fetch?: RequestInit;
    },
) => {
    const {query: queryOptions, fetch: fetchOptions} = options ?? {};

    const queryKey = queryOptions?.queryKey ?? getGetArtistQueryKey(id, params);

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getArtist>>> = ({
                                                                               signal,
                                                                           }) => getArtist(id, params, {signal, ...fetchOptions});

    return {
        queryKey,
        queryFn,
        enabled: !!id,
        ...queryOptions,
    } as UseQueryOptions<Awaited<ReturnType<typeof getArtist>>, TError, TData> & {
        queryKey: DataTag<QueryKey, TData, TError>;
    };
};

export type GetArtistQueryResult = NonNullable<
    Awaited<ReturnType<typeof getArtist>>
>;
export type GetArtistQueryError = unknown;

export function useGetArtist<
    TData = Awaited<ReturnType<typeof getArtist>>,
    TError = unknown,
>(
    id: number,
    params: undefined | GetArtistParams,
    options: {
        query: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof getArtist>>, TError, TData>
        > &
            Pick<
                DefinedInitialDataOptions<
                    Awaited<ReturnType<typeof getArtist>>,
                    TError,
                    Awaited<ReturnType<typeof getArtist>>
                >,
                "initialData"
            >;
        fetch?: RequestInit;
    },
    queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetArtist<
    TData = Awaited<ReturnType<typeof getArtist>>,
    TError = unknown,
>(
    id: number,
    params?: GetArtistParams,
    options?: {
        query?: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof getArtist>>, TError, TData>
        > &
            Pick<
                UndefinedInitialDataOptions<
                    Awaited<ReturnType<typeof getArtist>>,
                    TError,
                    Awaited<ReturnType<typeof getArtist>>
                >,
                "initialData"
            >;
        fetch?: RequestInit;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetArtist<
    TData = Awaited<ReturnType<typeof getArtist>>,
    TError = unknown,
>(
    id: number,
    params?: GetArtistParams,
    options?: {
        query?: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof getArtist>>, TError, TData>
        >;
        fetch?: RequestInit;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetArtist<
    TData = Awaited<ReturnType<typeof getArtist>>,
    TError = unknown,
>(
    id: number,
    params?: GetArtistParams,
    options?: {
        query?: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof getArtist>>, TError, TData>
        >;
        fetch?: RequestInit;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
} {
    const queryOptions = getGetArtistQueryOptions(id, params, options);

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<
        TData,
        TError
    > & { queryKey: DataTag<QueryKey, TData, TError> };

    return {...query, queryKey: queryOptions.queryKey};
}

export const invalidateGetArtist = async (
    queryClient: QueryClient,
    id: number,
    params?: GetArtistParams,
    options?: InvalidateOptions,
): Promise<QueryClient> => {
    await queryClient.invalidateQueries(
        {queryKey: getGetArtistQueryKey(id, params)},
        options,
    );

    return queryClient;
};

export type getArtistFilterMetadataResponse200 = {
    data: FilterMetadataResponse;
    status: 200;
};

export type getArtistFilterMetadataResponseSuccess =
    getArtistFilterMetadataResponse200 & {
    headers: Headers;
};

export type getArtistFilterMetadataResponse =
    getArtistFilterMetadataResponseSuccess;

export const getGetArtistFilterMetadataUrl = () => {
    return `/api/artists/filter-metadata`;
};

export const getArtistFilterMetadata = async (
    options?: RequestInit,
): Promise<getArtistFilterMetadataResponse> => {
    const res = await fetch(getGetArtistFilterMetadataUrl(), {
        ...options,
        method: "GET",
    });

    const body = [204, 205, 304].includes(res.status) ? null : await res.text();

    const data: getArtistFilterMetadataResponse["data"] = body
        ? JSON.parse(body)
        : {};
    return {
        data,
        status: res.status,
        headers: res.headers,
    } as getArtistFilterMetadataResponse;
};

export const getGetArtistFilterMetadataQueryKey = () => {
    return ["api", "artists", "filter-metadata"] as const;
};

export const getGetArtistFilterMetadataQueryOptions = <
    TData = Awaited<ReturnType<typeof getArtistFilterMetadata>>,
    TError = unknown,
>(options?: {
    query?: Partial<
        UseQueryOptions<
            Awaited<ReturnType<typeof getArtistFilterMetadata>>,
            TError,
            TData
        >
    >;
    fetch?: RequestInit;
}) => {
    const {query: queryOptions, fetch: fetchOptions} = options ?? {};

    const queryKey =
        queryOptions?.queryKey ?? getGetArtistFilterMetadataQueryKey();

    const queryFn: QueryFunction<
        Awaited<ReturnType<typeof getArtistFilterMetadata>>
    > = ({signal}) => getArtistFilterMetadata({signal, ...fetchOptions});

    return {queryKey, queryFn, ...queryOptions} as UseQueryOptions<
        Awaited<ReturnType<typeof getArtistFilterMetadata>>,
        TError,
        TData
    > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetArtistFilterMetadataQueryResult = NonNullable<
    Awaited<ReturnType<typeof getArtistFilterMetadata>>
>;
export type GetArtistFilterMetadataQueryError = unknown;

export function useGetArtistFilterMetadata<
    TData = Awaited<ReturnType<typeof getArtistFilterMetadata>>,
    TError = unknown,
>(
    options: {
        query: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getArtistFilterMetadata>>,
                TError,
                TData
            >
        > &
            Pick<
                DefinedInitialDataOptions<
                    Awaited<ReturnType<typeof getArtistFilterMetadata>>,
                    TError,
                    Awaited<ReturnType<typeof getArtistFilterMetadata>>
                >,
                "initialData"
            >;
        fetch?: RequestInit;
    },
    queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetArtistFilterMetadata<
    TData = Awaited<ReturnType<typeof getArtistFilterMetadata>>,
    TError = unknown,
>(
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getArtistFilterMetadata>>,
                TError,
                TData
            >
        > &
            Pick<
                UndefinedInitialDataOptions<
                    Awaited<ReturnType<typeof getArtistFilterMetadata>>,
                    TError,
                    Awaited<ReturnType<typeof getArtistFilterMetadata>>
                >,
                "initialData"
            >;
        fetch?: RequestInit;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetArtistFilterMetadata<
    TData = Awaited<ReturnType<typeof getArtistFilterMetadata>>,
    TError = unknown,
>(
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getArtistFilterMetadata>>,
                TError,
                TData
            >
        >;
        fetch?: RequestInit;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetArtistFilterMetadata<
    TData = Awaited<ReturnType<typeof getArtistFilterMetadata>>,
    TError = unknown,
>(
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getArtistFilterMetadata>>,
                TError,
                TData
            >
        >;
        fetch?: RequestInit;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
} {
    const queryOptions = getGetArtistFilterMetadataQueryOptions(options);

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<
        TData,
        TError
    > & { queryKey: DataTag<QueryKey, TData, TError> };

    return {...query, queryKey: queryOptions.queryKey};
}

export const invalidateGetArtistFilterMetadata = async (
    queryClient: QueryClient,
    options?: InvalidateOptions,
): Promise<QueryClient> => {
    await queryClient.invalidateQueries(
        {queryKey: getGetArtistFilterMetadataQueryKey()},
        options,
    );

    return queryClient;
};

export type getArtistFilterValuesResponse200 = {
    data: FilterValuesResponse;
    status: 200;
};

export type getArtistFilterValuesResponseSuccess =
    getArtistFilterValuesResponse200 & {
    headers: Headers;
};

export type getArtistFilterValuesResponse =
    getArtistFilterValuesResponseSuccess;

export const getGetArtistFilterValuesUrl = (
    params?: GetArtistFilterValuesParams,
) => {
    const normalizedParams = new URLSearchParams();

    Object.entries(params || {}).forEach(([key, value]) => {
        if (value !== undefined) {
            normalizedParams.append(key, value === null ? "null" : value.toString());
        }
    });

    const stringifiedParams = normalizedParams.toString();

    return stringifiedParams.length > 0
        ? `/api/artists/filter-values?${stringifiedParams}`
        : `/api/artists/filter-values`;
};

export const getArtistFilterValues = async (
    params?: GetArtistFilterValuesParams,
    options?: RequestInit,
): Promise<getArtistFilterValuesResponse> => {
    const res = await fetch(getGetArtistFilterValuesUrl(params), {
        ...options,
        method: "GET",
    });

    const body = [204, 205, 304].includes(res.status) ? null : await res.text();

    const data: getArtistFilterValuesResponse["data"] = body
        ? JSON.parse(body)
        : {};
    return {
        data,
        status: res.status,
        headers: res.headers,
    } as getArtistFilterValuesResponse;
};

export const getGetArtistFilterValuesQueryKey = (
    params?: GetArtistFilterValuesParams,
) => {
    return [
        "api",
        "artists",
        "filter-values",
        ...(params ? [params] : []),
    ] as const;
};

export const getGetArtistFilterValuesQueryOptions = <
    TData = Awaited<ReturnType<typeof getArtistFilterValues>>,
    TError = unknown,
>(
    params?: GetArtistFilterValuesParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getArtistFilterValues>>,
                TError,
                TData
            >
        >;
        fetch?: RequestInit;
    },
) => {
    const {query: queryOptions, fetch: fetchOptions} = options ?? {};

    const queryKey =
        queryOptions?.queryKey ?? getGetArtistFilterValuesQueryKey(params);

    const queryFn: QueryFunction<
        Awaited<ReturnType<typeof getArtistFilterValues>>
    > = ({signal}) =>
        getArtistFilterValues(params, {signal, ...fetchOptions});

    return {queryKey, queryFn, ...queryOptions} as UseQueryOptions<
        Awaited<ReturnType<typeof getArtistFilterValues>>,
        TError,
        TData
    > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetArtistFilterValuesQueryResult = NonNullable<
    Awaited<ReturnType<typeof getArtistFilterValues>>
>;
export type GetArtistFilterValuesQueryError = unknown;

export function useGetArtistFilterValues<
    TData = Awaited<ReturnType<typeof getArtistFilterValues>>,
    TError = unknown,
>(
    params: undefined | GetArtistFilterValuesParams,
    options: {
        query: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getArtistFilterValues>>,
                TError,
                TData
            >
        > &
            Pick<
                DefinedInitialDataOptions<
                    Awaited<ReturnType<typeof getArtistFilterValues>>,
                    TError,
                    Awaited<ReturnType<typeof getArtistFilterValues>>
                >,
                "initialData"
            >;
        fetch?: RequestInit;
    },
    queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetArtistFilterValues<
    TData = Awaited<ReturnType<typeof getArtistFilterValues>>,
    TError = unknown,
>(
    params?: GetArtistFilterValuesParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getArtistFilterValues>>,
                TError,
                TData
            >
        > &
            Pick<
                UndefinedInitialDataOptions<
                    Awaited<ReturnType<typeof getArtistFilterValues>>,
                    TError,
                    Awaited<ReturnType<typeof getArtistFilterValues>>
                >,
                "initialData"
            >;
        fetch?: RequestInit;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetArtistFilterValues<
    TData = Awaited<ReturnType<typeof getArtistFilterValues>>,
    TError = unknown,
>(
    params?: GetArtistFilterValuesParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getArtistFilterValues>>,
                TError,
                TData
            >
        >;
        fetch?: RequestInit;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetArtistFilterValues<
    TData = Awaited<ReturnType<typeof getArtistFilterValues>>,
    TError = unknown,
>(
    params?: GetArtistFilterValuesParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getArtistFilterValues>>,
                TError,
                TData
            >
        >;
        fetch?: RequestInit;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
} {
    const queryOptions = getGetArtistFilterValuesQueryOptions(params, options);

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<
        TData,
        TError
    > & { queryKey: DataTag<QueryKey, TData, TError> };

    return {...query, queryKey: queryOptions.queryKey};
}

export const invalidateGetArtistFilterValues = async (
    queryClient: QueryClient,
    params?: GetArtistFilterValuesParams,
    options?: InvalidateOptions,
): Promise<QueryClient> => {
    await queryClient.invalidateQueries(
        {queryKey: getGetArtistFilterValuesQueryKey(params)},
        options,
    );

    return queryClient;
};

export const getListArtistsResponseMock = (
    overrideResponse: Partial<ListArtistsResponse> = {},
): ListArtistsResponse => ({
    artists: Array.from(
        {length: faker.number.int({min: 1, max: 10})},
        (_, i) => i + 1,
    ).map(() => ({
        id: faker.number.int({min: undefined, max: undefined}),
        photo: faker.helpers.arrayElement([
            faker.helpers.arrayElement([
                faker.number.int({min: undefined, max: undefined}),
                null,
            ]),
            null,
        ]),
        name: faker.string.alpha({length: {min: 10, max: 20}}),
        albumsCount: faker.helpers.arrayElement([
            faker.helpers.arrayElement([
                faker.number.int({min: undefined, max: undefined}),
                null,
            ]),
            null,
        ]),
        songsCount: faker.helpers.arrayElement([
            faker.helpers.arrayElement([
                faker.number.int({min: undefined, max: undefined}),
                null,
            ]),
            null,
        ]),
        createdAt: faker.date.past().toISOString().slice(0, 19) + "Z",
    })),
    ...overrideResponse,
});

export const getGetArtistResponseMock = (
    overrideResponse: Partial<GetArtistResponse> = {},
): GetArtistResponse => ({
    artist: {
        id: faker.number.int({min: undefined, max: undefined}),
        photo: faker.helpers.arrayElement([
            faker.helpers.arrayElement([
                faker.number.int({min: undefined, max: undefined}),
                null,
            ]),
            null,
        ]),
        name: faker.string.alpha({length: {min: 10, max: 20}}),
        albumsCount: faker.number.int({min: undefined, max: undefined}),
        songsCount: faker.number.int({min: undefined, max: undefined}),
        createdAt: faker.date.past().toISOString().slice(0, 19) + "Z",
        albums: Array.from(
            {length: faker.number.int({min: 1, max: 10})},
            (_, i) => i + 1,
        ).map(() => ({
            id: faker.number.int({min: undefined, max: undefined}),
            cover: faker.helpers.arrayElement([
                faker.helpers.arrayElement([
                    faker.number.int({min: undefined, max: undefined}),
                    null,
                ]),
                null,
            ]),
            name: faker.string.alpha({length: {min: 10, max: 20}}),
            year: faker.helpers.arrayElement([
                faker.helpers.arrayElement([
                    faker.number.int({min: undefined, max: undefined}),
                    null,
                ]),
                null,
            ]),
            songsCount: faker.number.int({min: undefined, max: undefined}),
            createdAt: faker.date.past().toISOString().slice(0, 19) + "Z",
            artist: {
                id: faker.number.int({min: undefined, max: undefined}),
                name: faker.string.alpha({length: {min: 10, max: 20}}),
            },
        })),
        songs: Array.from(
            {length: faker.number.int({min: 1, max: 10})},
            (_, i) => i + 1,
        ).map(() => ({
            id: faker.number.int({min: undefined, max: undefined}),
            cover: faker.helpers.arrayElement([
                faker.helpers.arrayElement([
                    faker.number.int({min: undefined, max: undefined}),
                    null,
                ]),
                null,
            ]),
            title: faker.string.alpha({length: {min: 10, max: 20}}),
            artists: Array.from(
                {length: faker.number.int({min: 1, max: 10})},
                (_, i) => i + 1,
            ).map(() => ({
                id: faker.number.int({min: undefined, max: undefined}),
                name: faker.string.alpha({length: {min: 10, max: 20}}),
            })),
            album: {
                id: faker.number.int({min: undefined, max: undefined}),
                name: faker.string.alpha({length: {min: 10, max: 20}}),
            },
            genres: Array.from(
                {length: faker.number.int({min: 1, max: 10})},
                (_, i) => i + 1,
            ).map(() => ({
                id: faker.number.int({min: undefined, max: undefined}),
                name: faker.string.alpha({length: {min: 10, max: 20}}),
            })),
            year: faker.helpers.arrayElement([
                faker.helpers.arrayElement([
                    faker.number.int({min: undefined, max: undefined}),
                    null,
                ]),
                null,
            ]),
            duration: faker.string.alpha({length: {min: 10, max: 20}}),
            isFavorite: faker.datatype.boolean(),
            isExplicit: faker.datatype.boolean(),
        })),
    },
    ...overrideResponse,
});

export const getGetArtistFilterMetadataResponseMock = (
    overrideResponse: Partial<FilterMetadataResponse> = {},
): FilterMetadataResponse => ({
    fields: Array.from(
        {length: faker.number.int({min: 1, max: 10})},
        (_, i) => i + 1,
    ).map(() => ({
        name: faker.string.alpha({length: {min: 10, max: 20}}),
        type: faker.string.alpha({length: {min: 10, max: 20}}),
        description: faker.string.alpha({length: {min: 10, max: 20}}),
        supportedOperators: Array.from(
            {length: faker.number.int({min: 1, max: 10})},
            (_, i) => i + 1,
        ).map(() => faker.string.alpha({length: {min: 10, max: 20}})),
        isComputed: faker.helpers.arrayElement([
            faker.datatype.boolean(),
            undefined,
        ]),
        isCollection: faker.helpers.arrayElement([
            faker.datatype.boolean(),
            undefined,
        ]),
        nestedFields: faker.helpers.arrayElement([
            Array.from(
                {length: faker.number.int({min: 1, max: 10})},
                (_, i) => i + 1,
            ).map(() => ({})),
            undefined,
        ]),
        values: faker.helpers.arrayElement([
            Array.from(
                {length: faker.number.int({min: 1, max: 10})},
                (_, i) => i + 1,
            ).map(() => faker.string.alpha({length: {min: 10, max: 20}})),
            undefined,
        ]),
        supportsDynamicValues: faker.helpers.arrayElement([
            faker.datatype.boolean(),
            undefined,
        ]),
    })),
    operators: Array.from(
        {length: faker.number.int({min: 1, max: 10})},
        (_, i) => i + 1,
    ).map(() => ({
        name: faker.string.alpha({length: {min: 10, max: 20}}),
        displayName: faker.string.alpha({length: {min: 10, max: 20}}),
        description: faker.string.alpha({length: {min: 10, max: 20}}),
        applicableTypes: Array.from(
            {length: faker.number.int({min: 1, max: 10})},
            (_, i) => i + 1,
        ).map(() => faker.string.alpha({length: {min: 10, max: 20}})),
    })),
    ...overrideResponse,
});

export const getGetArtistFilterValuesResponseMock = (
    overrideResponse: Partial<FilterValuesResponse> = {},
): FilterValuesResponse => ({
    values: Array.from(
        {length: faker.number.int({min: 1, max: 10})},
        (_, i) => i + 1,
    ).map(() => faker.string.alpha({length: {min: 10, max: 20}})),
    ...overrideResponse,
});

export const getListArtistsMockHandler = (
    overrideResponse?:
        | ListArtistsResponse
        | ((
        info: Parameters<Parameters<typeof http.get>[1]>[0],
    ) => Promise<ListArtistsResponse> | ListArtistsResponse),
    options?: RequestHandlerOptions,
) => {
    return http.get(
        "*/artists",
        async (info) => {
            return new HttpResponse(
                overrideResponse !== undefined
                    ? typeof overrideResponse === "function"
                        ? await overrideResponse(info)
                        : overrideResponse
                    : getListArtistsResponseMock(),
                {status: 200, headers: {"Content-Type": "text/plain"}},
            );
        },
        options,
    );
};

export const getGetArtistMockHandler = (
    overrideResponse?:
        | GetArtistResponse
        | ((
        info: Parameters<Parameters<typeof http.get>[1]>[0],
    ) => Promise<GetArtistResponse> | GetArtistResponse),
    options?: RequestHandlerOptions,
) => {
    return http.get(
        "*/artists/:id",
        async (info) => {
            return new HttpResponse(
                overrideResponse !== undefined
                    ? typeof overrideResponse === "function"
                        ? await overrideResponse(info)
                        : overrideResponse
                    : getGetArtistResponseMock(),
                {status: 200, headers: {"Content-Type": "text/plain"}},
            );
        },
        options,
    );
};

export const getGetArtistFilterMetadataMockHandler = (
    overrideResponse?:
        | FilterMetadataResponse
        | ((
        info: Parameters<Parameters<typeof http.get>[1]>[0],
    ) => Promise<FilterMetadataResponse> | FilterMetadataResponse),
    options?: RequestHandlerOptions,
) => {
    return http.get(
        "*/artists/filter-metadata",
        async (info) => {
            return new HttpResponse(
                overrideResponse !== undefined
                    ? typeof overrideResponse === "function"
                        ? await overrideResponse(info)
                        : overrideResponse
                    : getGetArtistFilterMetadataResponseMock(),
                {status: 200, headers: {"Content-Type": "text/plain"}},
            );
        },
        options,
    );
};

export const getGetArtistFilterValuesMockHandler = (
    overrideResponse?:
        | FilterValuesResponse
        | ((
        info: Parameters<Parameters<typeof http.get>[1]>[0],
    ) => Promise<FilterValuesResponse> | FilterValuesResponse),
    options?: RequestHandlerOptions,
) => {
    return http.get(
        "*/artists/filter-values",
        async (info) => {
            return new HttpResponse(
                overrideResponse !== undefined
                    ? typeof overrideResponse === "function"
                        ? await overrideResponse(info)
                        : overrideResponse
                    : getGetArtistFilterValuesResponseMock(),
                {status: 200, headers: {"Content-Type": "text/plain"}},
            );
        },
        options,
    );
};
export const getArtistsMock = () => [
    getListArtistsMockHandler(),
    getGetArtistMockHandler(),
    getGetArtistFilterMetadataMockHandler(),
    getGetArtistFilterValuesMockHandler(),
];
