/**
 * Generated by orval v8.2.0 ðŸº
 * Do not edit manually.
 * MyMusic.Server | v1
 * OpenAPI spec version: 1.0.0
 */

import {faker} from "@faker-js/faker";
import type {
    DataTag,
    DefinedInitialDataOptions,
    DefinedUseQueryResult,
    InvalidateOptions,
    MutationFunction,
    QueryClient,
    QueryFunction,
    QueryKey,
    UndefinedInitialDataOptions,
    UseMutationOptions,
    UseMutationResult,
    UseQueryOptions,
    UseQueryResult,
} from "@tanstack/react-query";
import {useMutation, useQuery, useQueryClient} from "@tanstack/react-query";
import type {RequestHandlerOptions} from "msw";

import {HttpResponse, http} from "msw";
import type {
    CreatePurchaseResponse,
    DeleteManyPurchasesParams,
    DeleteManyPurchasesResponse,
    DeletePurchaseResponse,
    ListPurchasesResponse,
    RequeueManyPurchasesParams,
    RequeueManyPurchasesResponse,
    RequeuePurchaseResponse,
} from "../model";
import {PurchasedSongStatus} from "../model";

export type listPurchasesResponse200 = {
    data: ListPurchasesResponse;
    status: 200;
};

export type listPurchasesResponseSuccess = listPurchasesResponse200 & {
    headers: Headers;
};

export type listPurchasesResponse = listPurchasesResponseSuccess;

export const getListPurchasesUrl = () => {
    return `/api/purchases`;
};

export const listPurchases = async (
    options?: RequestInit,
): Promise<listPurchasesResponse> => {
    const res = await fetch(getListPurchasesUrl(), {
        ...options,
        method: "GET",
    });

    const body = [204, 205, 304].includes(res.status) ? null : await res.text();

    const data: listPurchasesResponse["data"] = body ? JSON.parse(body) : {};
    return {
        data,
        status: res.status,
        headers: res.headers,
    } as listPurchasesResponse;
};

export const getListPurchasesQueryKey = () => {
    return ["api", "purchases"] as const;
};

export const getListPurchasesQueryOptions = <
    TData = Awaited<ReturnType<typeof listPurchases>>,
    TError = unknown,
>(options?: {
    query?: Partial<
        UseQueryOptions<Awaited<ReturnType<typeof listPurchases>>, TError, TData>
    >;
    fetch?: RequestInit;
}) => {
    const {query: queryOptions, fetch: fetchOptions} = options ?? {};

    const queryKey = queryOptions?.queryKey ?? getListPurchasesQueryKey();

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listPurchases>>> = ({
                                                                                   signal,
                                                                               }) => listPurchases({signal, ...fetchOptions});

    return {queryKey, queryFn, ...queryOptions} as UseQueryOptions<
        Awaited<ReturnType<typeof listPurchases>>,
        TError,
        TData
    > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ListPurchasesQueryResult = NonNullable<
    Awaited<ReturnType<typeof listPurchases>>
>;
export type ListPurchasesQueryError = unknown;

export function useListPurchases<
    TData = Awaited<ReturnType<typeof listPurchases>>,
    TError = unknown,
>(
    options: {
        query: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof listPurchases>>, TError, TData>
        > &
            Pick<
                DefinedInitialDataOptions<
                    Awaited<ReturnType<typeof listPurchases>>,
                    TError,
                    Awaited<ReturnType<typeof listPurchases>>
                >,
                "initialData"
            >;
        fetch?: RequestInit;
    },
    queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useListPurchases<
    TData = Awaited<ReturnType<typeof listPurchases>>,
    TError = unknown,
>(
    options?: {
        query?: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof listPurchases>>, TError, TData>
        > &
            Pick<
                UndefinedInitialDataOptions<
                    Awaited<ReturnType<typeof listPurchases>>,
                    TError,
                    Awaited<ReturnType<typeof listPurchases>>
                >,
                "initialData"
            >;
        fetch?: RequestInit;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useListPurchases<
    TData = Awaited<ReturnType<typeof listPurchases>>,
    TError = unknown,
>(
    options?: {
        query?: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof listPurchases>>, TError, TData>
        >;
        fetch?: RequestInit;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};

export function useListPurchases<
    TData = Awaited<ReturnType<typeof listPurchases>>,
    TError = unknown,
>(
    options?: {
        query?: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof listPurchases>>, TError, TData>
        >;
        fetch?: RequestInit;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
} {
    const queryOptions = getListPurchasesQueryOptions(options);

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<
        TData,
        TError
    > & { queryKey: DataTag<QueryKey, TData, TError> };

    return {...query, queryKey: queryOptions.queryKey};
}

export const invalidateListPurchases = async (
    queryClient: QueryClient,
    options?: InvalidateOptions,
): Promise<QueryClient> => {
    await queryClient.invalidateQueries(
        {queryKey: getListPurchasesQueryKey()},
        options,
    );

    return queryClient;
};

export type deleteManyPurchasesResponse200 = {
    data: DeleteManyPurchasesResponse;
    status: 200;
};

export type deleteManyPurchasesResponseSuccess =
    deleteManyPurchasesResponse200 & {
    headers: Headers;
};

export type deleteManyPurchasesResponse = deleteManyPurchasesResponseSuccess;

export const getDeleteManyPurchasesUrl = (
    params?: DeleteManyPurchasesParams,
) => {
    const normalizedParams = new URLSearchParams();

    Object.entries(params || {}).forEach(([key, value]) => {
        if (value !== undefined) {
            normalizedParams.append(key, value === null ? "null" : value.toString());
        }
    });

    const stringifiedParams = normalizedParams.toString();

    return stringifiedParams.length > 0
        ? `/api/purchases?${stringifiedParams}`
        : `/api/purchases`;
};

export const deleteManyPurchases = async (
    params?: DeleteManyPurchasesParams,
    options?: RequestInit,
): Promise<deleteManyPurchasesResponse> => {
    const res = await fetch(getDeleteManyPurchasesUrl(params), {
        ...options,
        method: "DELETE",
    });

    const body = [204, 205, 304].includes(res.status) ? null : await res.text();

    const data: deleteManyPurchasesResponse["data"] = body
        ? JSON.parse(body)
        : {};
    return {
        data,
        status: res.status,
        headers: res.headers,
    } as deleteManyPurchasesResponse;
};

export const getDeleteManyPurchasesMutationOptions = <
    TError = unknown,
    TContext = unknown,
>(
    queryClient: QueryClient,
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof deleteManyPurchases>>,
            TError,
            { params?: DeleteManyPurchasesParams },
            TContext
        >;
        fetch?: RequestInit;
    },
): UseMutationOptions<
    Awaited<ReturnType<typeof deleteManyPurchases>>,
    TError,
    { params?: DeleteManyPurchasesParams },
    TContext
> => {
    const mutationKey = ["deleteManyPurchases"];
    const {mutation: mutationOptions, fetch: fetchOptions} = options
        ? options.mutation &&
        "mutationKey" in options.mutation &&
        options.mutation.mutationKey
            ? options
            : {...options, mutation: {...options.mutation, mutationKey}}
        : {mutation: {mutationKey}, fetch: undefined};

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof deleteManyPurchases>>,
        { params?: DeleteManyPurchasesParams }
    > = (props) => {
        const {params} = props ?? {};

        return deleteManyPurchases(params, fetchOptions);
    };

    const onSuccess = (
        data: Awaited<ReturnType<typeof deleteManyPurchases>>,
        variables: { params?: DeleteManyPurchasesParams },
        context: TContext,
    ) => {
        queryClient.invalidateQueries({queryKey: getListPurchasesQueryKey()});
        mutationOptions?.onSuccess?.(data, variables, context);
    };

    return {mutationFn, onSuccess, ...mutationOptions};
};

export type DeleteManyPurchasesMutationResult = NonNullable<
    Awaited<ReturnType<typeof deleteManyPurchases>>
>;

export type DeleteManyPurchasesMutationError = unknown;

export const useDeleteManyPurchases = <TError = unknown, TContext = unknown>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof deleteManyPurchases>>,
            TError,
            { params?: DeleteManyPurchasesParams },
            TContext
        >;
        fetch?: RequestInit;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof deleteManyPurchases>>,
    TError,
    { params?: DeleteManyPurchasesParams },
    TContext
> => {
    const backupQueryClient = useQueryClient();
    return useMutation(
        getDeleteManyPurchasesMutationOptions(
            queryClient ?? backupQueryClient,
            options,
        ),
        queryClient,
    );
};
export type createPurchaseResponse200 = {
    data: CreatePurchaseResponse;
    status: 200;
};

export type createPurchaseResponseSuccess = createPurchaseResponse200 & {
    headers: Headers;
};

export type createPurchaseResponse = createPurchaseResponseSuccess;

export const getCreatePurchaseUrl = (sourceId: number, songId: string) => {
    return `/api/purchases/create/${sourceId}/${songId}`;
};

export const createPurchase = async (
    sourceId: number,
    songId: string,
    options?: RequestInit,
): Promise<createPurchaseResponse> => {
    const res = await fetch(getCreatePurchaseUrl(sourceId, songId), {
        ...options,
        method: "POST",
    });

    const body = [204, 205, 304].includes(res.status) ? null : await res.text();

    const data: createPurchaseResponse["data"] = body ? JSON.parse(body) : {};
    return {
        data,
        status: res.status,
        headers: res.headers,
    } as createPurchaseResponse;
};

export const getCreatePurchaseMutationOptions = <
    TError = unknown,
    TContext = unknown,
>(
    queryClient: QueryClient,
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof createPurchase>>,
            TError,
            { sourceId: number; songId: string },
            TContext
        >;
        fetch?: RequestInit;
    },
): UseMutationOptions<
    Awaited<ReturnType<typeof createPurchase>>,
    TError,
    { sourceId: number; songId: string },
    TContext
> => {
    const mutationKey = ["createPurchase"];
    const {mutation: mutationOptions, fetch: fetchOptions} = options
        ? options.mutation &&
        "mutationKey" in options.mutation &&
        options.mutation.mutationKey
            ? options
            : {...options, mutation: {...options.mutation, mutationKey}}
        : {mutation: {mutationKey}, fetch: undefined};

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof createPurchase>>,
        { sourceId: number; songId: string }
    > = (props) => {
        const {sourceId, songId} = props ?? {};

        return createPurchase(sourceId, songId, fetchOptions);
    };

    const onSuccess = (
        data: Awaited<ReturnType<typeof createPurchase>>,
        variables: { sourceId: number; songId: string },
        context: TContext,
    ) => {
        queryClient.invalidateQueries({queryKey: getListPurchasesQueryKey()});
        mutationOptions?.onSuccess?.(data, variables, context);
    };

    return {mutationFn, onSuccess, ...mutationOptions};
};

export type CreatePurchaseMutationResult = NonNullable<
    Awaited<ReturnType<typeof createPurchase>>
>;

export type CreatePurchaseMutationError = unknown;

export const useCreatePurchase = <TError = unknown, TContext = unknown>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof createPurchase>>,
            TError,
            { sourceId: number; songId: string },
            TContext
        >;
        fetch?: RequestInit;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof createPurchase>>,
    TError,
    { sourceId: number; songId: string },
    TContext
> => {
    const backupQueryClient = useQueryClient();
    return useMutation(
        getCreatePurchaseMutationOptions(queryClient ?? backupQueryClient, options),
        queryClient,
    );
};
export type requeueManyPurchasesResponse200 = {
    data: RequeueManyPurchasesResponse;
    status: 200;
};

export type requeueManyPurchasesResponseSuccess =
    requeueManyPurchasesResponse200 & {
    headers: Headers;
};

export type requeueManyPurchasesResponse = requeueManyPurchasesResponseSuccess;

export const getRequeueManyPurchasesUrl = (
    params?: RequeueManyPurchasesParams,
) => {
    const normalizedParams = new URLSearchParams();

    Object.entries(params || {}).forEach(([key, value]) => {
        if (value !== undefined) {
            normalizedParams.append(key, value === null ? "null" : value.toString());
        }
    });

    const stringifiedParams = normalizedParams.toString();

    return stringifiedParams.length > 0
        ? `/api/purchases/requeue?${stringifiedParams}`
        : `/api/purchases/requeue`;
};

export const requeueManyPurchases = async (
    params?: RequeueManyPurchasesParams,
    options?: RequestInit,
): Promise<requeueManyPurchasesResponse> => {
    const res = await fetch(getRequeueManyPurchasesUrl(params), {
        ...options,
        method: "POST",
    });

    const body = [204, 205, 304].includes(res.status) ? null : await res.text();

    const data: requeueManyPurchasesResponse["data"] = body
        ? JSON.parse(body)
        : {};
    return {
        data,
        status: res.status,
        headers: res.headers,
    } as requeueManyPurchasesResponse;
};

export const getRequeueManyPurchasesMutationOptions = <
    TError = unknown,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof requeueManyPurchases>>,
        TError,
        { params?: RequeueManyPurchasesParams },
        TContext
    >;
    fetch?: RequestInit;
}): UseMutationOptions<
    Awaited<ReturnType<typeof requeueManyPurchases>>,
    TError,
    { params?: RequeueManyPurchasesParams },
    TContext
> => {
    const mutationKey = ["requeueManyPurchases"];
    const {mutation: mutationOptions, fetch: fetchOptions} = options
        ? options.mutation &&
        "mutationKey" in options.mutation &&
        options.mutation.mutationKey
            ? options
            : {...options, mutation: {...options.mutation, mutationKey}}
        : {mutation: {mutationKey}, fetch: undefined};

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof requeueManyPurchases>>,
        { params?: RequeueManyPurchasesParams }
    > = (props) => {
        const {params} = props ?? {};

        return requeueManyPurchases(params, fetchOptions);
    };

    return {mutationFn, ...mutationOptions};
};

export type RequeueManyPurchasesMutationResult = NonNullable<
    Awaited<ReturnType<typeof requeueManyPurchases>>
>;

export type RequeueManyPurchasesMutationError = unknown;

export const useRequeueManyPurchases = <TError = unknown, TContext = unknown>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof requeueManyPurchases>>,
            TError,
            { params?: RequeueManyPurchasesParams },
            TContext
        >;
        fetch?: RequestInit;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof requeueManyPurchases>>,
    TError,
    { params?: RequeueManyPurchasesParams },
    TContext
> => {
    return useMutation(
        getRequeueManyPurchasesMutationOptions(options),
        queryClient,
    );
};
export type requeuePurchaseResponse200 = {
    data: RequeuePurchaseResponse;
    status: 200;
};

export type requeuePurchaseResponseSuccess = requeuePurchaseResponse200 & {
    headers: Headers;
};

export type requeuePurchaseResponse = requeuePurchaseResponseSuccess;

export const getRequeuePurchaseUrl = (id: number) => {
    return `/api/purchases/${id}/requeue`;
};

export const requeuePurchase = async (
    id: number,
    options?: RequestInit,
): Promise<requeuePurchaseResponse> => {
    const res = await fetch(getRequeuePurchaseUrl(id), {
        ...options,
        method: "POST",
    });

    const body = [204, 205, 304].includes(res.status) ? null : await res.text();

    const data: requeuePurchaseResponse["data"] = body ? JSON.parse(body) : {};
    return {
        data,
        status: res.status,
        headers: res.headers,
    } as requeuePurchaseResponse;
};

export const getRequeuePurchaseMutationOptions = <
    TError = unknown,
    TContext = unknown,
>(
    queryClient: QueryClient,
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof requeuePurchase>>,
            TError,
            { id: number },
            TContext
        >;
        fetch?: RequestInit;
    },
): UseMutationOptions<
    Awaited<ReturnType<typeof requeuePurchase>>,
    TError,
    { id: number },
    TContext
> => {
    const mutationKey = ["requeuePurchase"];
    const {mutation: mutationOptions, fetch: fetchOptions} = options
        ? options.mutation &&
        "mutationKey" in options.mutation &&
        options.mutation.mutationKey
            ? options
            : {...options, mutation: {...options.mutation, mutationKey}}
        : {mutation: {mutationKey}, fetch: undefined};

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof requeuePurchase>>,
        { id: number }
    > = (props) => {
        const {id} = props ?? {};

        return requeuePurchase(id, fetchOptions);
    };

    const onSuccess = (
        data: Awaited<ReturnType<typeof requeuePurchase>>,
        variables: { id: number },
        context: TContext,
    ) => {
        queryClient.invalidateQueries({queryKey: getListPurchasesQueryKey()});
        mutationOptions?.onSuccess?.(data, variables, context);
    };

    return {mutationFn, onSuccess, ...mutationOptions};
};

export type RequeuePurchaseMutationResult = NonNullable<
    Awaited<ReturnType<typeof requeuePurchase>>
>;

export type RequeuePurchaseMutationError = unknown;

export const useRequeuePurchase = <TError = unknown, TContext = unknown>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof requeuePurchase>>,
            TError,
            { id: number },
            TContext
        >;
        fetch?: RequestInit;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof requeuePurchase>>,
    TError,
    { id: number },
    TContext
> => {
    const backupQueryClient = useQueryClient();
    return useMutation(
        getRequeuePurchaseMutationOptions(
            queryClient ?? backupQueryClient,
            options,
        ),
        queryClient,
    );
};
export type deletePurchaseResponse200 = {
    data: DeletePurchaseResponse;
    status: 200;
};

export type deletePurchaseResponseSuccess = deletePurchaseResponse200 & {
    headers: Headers;
};

export type deletePurchaseResponse = deletePurchaseResponseSuccess;

export const getDeletePurchaseUrl = (id: number) => {
    return `/api/purchases/${id}`;
};

export const deletePurchase = async (
    id: number,
    options?: RequestInit,
): Promise<deletePurchaseResponse> => {
    const res = await fetch(getDeletePurchaseUrl(id), {
        ...options,
        method: "DELETE",
    });

    const body = [204, 205, 304].includes(res.status) ? null : await res.text();

    const data: deletePurchaseResponse["data"] = body ? JSON.parse(body) : {};
    return {
        data,
        status: res.status,
        headers: res.headers,
    } as deletePurchaseResponse;
};

export const getDeletePurchaseMutationOptions = <
    TError = unknown,
    TContext = unknown,
>(
    queryClient: QueryClient,
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof deletePurchase>>,
            TError,
            { id: number },
            TContext
        >;
        fetch?: RequestInit;
    },
): UseMutationOptions<
    Awaited<ReturnType<typeof deletePurchase>>,
    TError,
    { id: number },
    TContext
> => {
    const mutationKey = ["deletePurchase"];
    const {mutation: mutationOptions, fetch: fetchOptions} = options
        ? options.mutation &&
        "mutationKey" in options.mutation &&
        options.mutation.mutationKey
            ? options
            : {...options, mutation: {...options.mutation, mutationKey}}
        : {mutation: {mutationKey}, fetch: undefined};

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof deletePurchase>>,
        { id: number }
    > = (props) => {
        const {id} = props ?? {};

        return deletePurchase(id, fetchOptions);
    };

    const onSuccess = (
        data: Awaited<ReturnType<typeof deletePurchase>>,
        variables: { id: number },
        context: TContext,
    ) => {
        queryClient.invalidateQueries({queryKey: getListPurchasesQueryKey()});
        mutationOptions?.onSuccess?.(data, variables, context);
    };

    return {mutationFn, onSuccess, ...mutationOptions};
};

export type DeletePurchaseMutationResult = NonNullable<
    Awaited<ReturnType<typeof deletePurchase>>
>;

export type DeletePurchaseMutationError = unknown;

export const useDeletePurchase = <TError = unknown, TContext = unknown>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof deletePurchase>>,
            TError,
            { id: number },
            TContext
        >;
        fetch?: RequestInit;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof deletePurchase>>,
    TError,
    { id: number },
    TContext
> => {
    const backupQueryClient = useQueryClient();
    return useMutation(
        getDeletePurchaseMutationOptions(queryClient ?? backupQueryClient, options),
        queryClient,
    );
};

export const getListPurchasesResponseMock = (
    overrideResponse: Partial<ListPurchasesResponse> = {},
): ListPurchasesResponse => ({
    purchases: Array.from(
        {length: faker.number.int({min: 1, max: 10})},
        (_, i) => i + 1,
    ).map(() => ({
        id: faker.number.int({min: undefined, max: undefined}),
        sourceId: faker.number.int({min: undefined, max: undefined}),
        sourceName: faker.string.alpha({length: {min: 10, max: 20}}),
        sourceIcon: faker.string.alpha({length: {min: 10, max: 20}}),
        userId: faker.number.int({min: undefined, max: undefined}),
        externalId: faker.string.alpha({length: {min: 10, max: 20}}),
        cover: faker.helpers.arrayElement([
            faker.helpers.arrayElement([
                faker.string.alpha({length: {min: 10, max: 20}}),
                null,
            ]),
            undefined,
        ]),
        title: faker.string.alpha({length: {min: 10, max: 20}}),
        subTitle: faker.string.alpha({length: {min: 10, max: 20}}),
        status: faker.helpers.arrayElement(Object.values(PurchasedSongStatus)),
        progress: faker.number.int({min: undefined, max: undefined}),
        songId: faker.helpers.arrayElement([
            faker.helpers.arrayElement([
                faker.number.int({min: undefined, max: undefined}),
                null,
            ]),
            undefined,
        ]),
        errorMessage: faker.helpers.arrayElement([
            faker.helpers.arrayElement([
                faker.string.alpha({length: {min: 10, max: 20}}),
                null,
            ]),
            null,
        ]),
        createdAt: faker.date.past().toISOString().slice(0, 19) + "Z",
    })),
    ...overrideResponse,
});

export const getDeleteManyPurchasesResponseMock = (
    overrideResponse: Partial<DeleteManyPurchasesResponse> = {},
): DeleteManyPurchasesResponse => ({
    purchases: Array.from(
        {length: faker.number.int({min: 1, max: 10})},
        (_, i) => i + 1,
    ).map(() => ({
        id: faker.number.int({min: undefined, max: undefined}),
        sourceId: faker.number.int({min: undefined, max: undefined}),
        sourceName: faker.string.alpha({length: {min: 10, max: 20}}),
        sourceIcon: faker.string.alpha({length: {min: 10, max: 20}}),
        userId: faker.number.int({min: undefined, max: undefined}),
        externalId: faker.string.alpha({length: {min: 10, max: 20}}),
        cover: faker.helpers.arrayElement([
            faker.helpers.arrayElement([
                faker.string.alpha({length: {min: 10, max: 20}}),
                null,
            ]),
            undefined,
        ]),
        title: faker.string.alpha({length: {min: 10, max: 20}}),
        subTitle: faker.string.alpha({length: {min: 10, max: 20}}),
        status: faker.helpers.arrayElement(Object.values(PurchasedSongStatus)),
        progress: faker.number.int({min: undefined, max: undefined}),
        songId: faker.helpers.arrayElement([
            faker.helpers.arrayElement([
                faker.number.int({min: undefined, max: undefined}),
                null,
            ]),
            undefined,
        ]),
        errorMessage: faker.helpers.arrayElement([
            faker.helpers.arrayElement([
                faker.string.alpha({length: {min: 10, max: 20}}),
                null,
            ]),
            null,
        ]),
        createdAt: faker.date.past().toISOString().slice(0, 19) + "Z",
    })),
    ...overrideResponse,
});

export const getCreatePurchaseResponseMock = (
    overrideResponse: Partial<CreatePurchaseResponse> = {},
): CreatePurchaseResponse => ({
    purchase: {
        id: faker.number.int({min: undefined, max: undefined}),
        sourceId: faker.number.int({min: undefined, max: undefined}),
        sourceName: faker.string.alpha({length: {min: 10, max: 20}}),
        sourceIcon: faker.string.alpha({length: {min: 10, max: 20}}),
        userId: faker.number.int({min: undefined, max: undefined}),
        externalId: faker.string.alpha({length: {min: 10, max: 20}}),
        cover: faker.helpers.arrayElement([
            faker.helpers.arrayElement([
                faker.string.alpha({length: {min: 10, max: 20}}),
                null,
            ]),
            undefined,
        ]),
        title: faker.string.alpha({length: {min: 10, max: 20}}),
        subTitle: faker.string.alpha({length: {min: 10, max: 20}}),
        status: faker.helpers.arrayElement(Object.values(PurchasedSongStatus)),
        progress: faker.number.int({min: undefined, max: undefined}),
        songId: faker.helpers.arrayElement([
            faker.helpers.arrayElement([
                faker.number.int({min: undefined, max: undefined}),
                null,
            ]),
            undefined,
        ]),
        errorMessage: faker.helpers.arrayElement([
            faker.helpers.arrayElement([
                faker.string.alpha({length: {min: 10, max: 20}}),
                null,
            ]),
            null,
        ]),
        createdAt: faker.date.past().toISOString().slice(0, 19) + "Z",
    },
    ...overrideResponse,
});

export const getRequeueManyPurchasesResponseMock = (
    overrideResponse: Partial<RequeueManyPurchasesResponse> = {},
): RequeueManyPurchasesResponse => ({
    purchases: Array.from(
        {length: faker.number.int({min: 1, max: 10})},
        (_, i) => i + 1,
    ).map(() => ({
        id: faker.number.int({min: undefined, max: undefined}),
        sourceId: faker.number.int({min: undefined, max: undefined}),
        sourceName: faker.string.alpha({length: {min: 10, max: 20}}),
        sourceIcon: faker.string.alpha({length: {min: 10, max: 20}}),
        userId: faker.number.int({min: undefined, max: undefined}),
        externalId: faker.string.alpha({length: {min: 10, max: 20}}),
        cover: faker.helpers.arrayElement([
            faker.helpers.arrayElement([
                faker.string.alpha({length: {min: 10, max: 20}}),
                null,
            ]),
            undefined,
        ]),
        title: faker.string.alpha({length: {min: 10, max: 20}}),
        subTitle: faker.string.alpha({length: {min: 10, max: 20}}),
        status: faker.helpers.arrayElement(Object.values(PurchasedSongStatus)),
        progress: faker.number.int({min: undefined, max: undefined}),
        songId: faker.helpers.arrayElement([
            faker.helpers.arrayElement([
                faker.number.int({min: undefined, max: undefined}),
                null,
            ]),
            undefined,
        ]),
        errorMessage: faker.helpers.arrayElement([
            faker.helpers.arrayElement([
                faker.string.alpha({length: {min: 10, max: 20}}),
                null,
            ]),
            null,
        ]),
        createdAt: faker.date.past().toISOString().slice(0, 19) + "Z",
    })),
    ...overrideResponse,
});

export const getRequeuePurchaseResponseMock = (
    overrideResponse: Partial<RequeuePurchaseResponse> = {},
): RequeuePurchaseResponse => ({
    purchase: {
        id: faker.number.int({min: undefined, max: undefined}),
        sourceId: faker.number.int({min: undefined, max: undefined}),
        sourceName: faker.string.alpha({length: {min: 10, max: 20}}),
        sourceIcon: faker.string.alpha({length: {min: 10, max: 20}}),
        userId: faker.number.int({min: undefined, max: undefined}),
        externalId: faker.string.alpha({length: {min: 10, max: 20}}),
        cover: faker.helpers.arrayElement([
            faker.helpers.arrayElement([
                faker.string.alpha({length: {min: 10, max: 20}}),
                null,
            ]),
            undefined,
        ]),
        title: faker.string.alpha({length: {min: 10, max: 20}}),
        subTitle: faker.string.alpha({length: {min: 10, max: 20}}),
        status: faker.helpers.arrayElement(Object.values(PurchasedSongStatus)),
        progress: faker.number.int({min: undefined, max: undefined}),
        songId: faker.helpers.arrayElement([
            faker.helpers.arrayElement([
                faker.number.int({min: undefined, max: undefined}),
                null,
            ]),
            undefined,
        ]),
        errorMessage: faker.helpers.arrayElement([
            faker.helpers.arrayElement([
                faker.string.alpha({length: {min: 10, max: 20}}),
                null,
            ]),
            null,
        ]),
        createdAt: faker.date.past().toISOString().slice(0, 19) + "Z",
    },
    ...overrideResponse,
});

export const getDeletePurchaseResponseMock = (
    overrideResponse: Partial<DeletePurchaseResponse> = {},
): DeletePurchaseResponse => ({
    purchase: {
        id: faker.number.int({min: undefined, max: undefined}),
        sourceId: faker.number.int({min: undefined, max: undefined}),
        sourceName: faker.string.alpha({length: {min: 10, max: 20}}),
        sourceIcon: faker.string.alpha({length: {min: 10, max: 20}}),
        userId: faker.number.int({min: undefined, max: undefined}),
        externalId: faker.string.alpha({length: {min: 10, max: 20}}),
        cover: faker.helpers.arrayElement([
            faker.helpers.arrayElement([
                faker.string.alpha({length: {min: 10, max: 20}}),
                null,
            ]),
            undefined,
        ]),
        title: faker.string.alpha({length: {min: 10, max: 20}}),
        subTitle: faker.string.alpha({length: {min: 10, max: 20}}),
        status: faker.helpers.arrayElement(Object.values(PurchasedSongStatus)),
        progress: faker.number.int({min: undefined, max: undefined}),
        songId: faker.helpers.arrayElement([
            faker.helpers.arrayElement([
                faker.number.int({min: undefined, max: undefined}),
                null,
            ]),
            undefined,
        ]),
        errorMessage: faker.helpers.arrayElement([
            faker.helpers.arrayElement([
                faker.string.alpha({length: {min: 10, max: 20}}),
                null,
            ]),
            null,
        ]),
        createdAt: faker.date.past().toISOString().slice(0, 19) + "Z",
    },
    ...overrideResponse,
});

export const getListPurchasesMockHandler = (
    overrideResponse?:
        | ListPurchasesResponse
        | ((
        info: Parameters<Parameters<typeof http.get>[1]>[0],
    ) => Promise<ListPurchasesResponse> | ListPurchasesResponse),
    options?: RequestHandlerOptions,
) => {
    return http.get(
        "*/purchases",
        async (info) => {
            return new HttpResponse(
                overrideResponse !== undefined
                    ? typeof overrideResponse === "function"
                        ? await overrideResponse(info)
                        : overrideResponse
                    : getListPurchasesResponseMock(),
                {status: 200, headers: {"Content-Type": "text/plain"}},
            );
        },
        options,
    );
};

export const getDeleteManyPurchasesMockHandler = (
    overrideResponse?:
        | DeleteManyPurchasesResponse
        | ((
        info: Parameters<Parameters<typeof http.delete>[1]>[0],
    ) => Promise<DeleteManyPurchasesResponse> | DeleteManyPurchasesResponse),
    options?: RequestHandlerOptions,
) => {
    return http.delete(
        "*/purchases",
        async (info) => {
            return new HttpResponse(
                overrideResponse !== undefined
                    ? typeof overrideResponse === "function"
                        ? await overrideResponse(info)
                        : overrideResponse
                    : getDeleteManyPurchasesResponseMock(),
                {status: 200, headers: {"Content-Type": "text/plain"}},
            );
        },
        options,
    );
};

export const getCreatePurchaseMockHandler = (
    overrideResponse?:
        | CreatePurchaseResponse
        | ((
        info: Parameters<Parameters<typeof http.post>[1]>[0],
    ) => Promise<CreatePurchaseResponse> | CreatePurchaseResponse),
    options?: RequestHandlerOptions,
) => {
    return http.post(
        "*/purchases/create/:sourceId/:songId",
        async (info) => {
            return new HttpResponse(
                overrideResponse !== undefined
                    ? typeof overrideResponse === "function"
                        ? await overrideResponse(info)
                        : overrideResponse
                    : getCreatePurchaseResponseMock(),
                {status: 200, headers: {"Content-Type": "text/plain"}},
            );
        },
        options,
    );
};

export const getRequeueManyPurchasesMockHandler = (
    overrideResponse?:
        | RequeueManyPurchasesResponse
        | ((
        info: Parameters<Parameters<typeof http.post>[1]>[0],
    ) =>
        | Promise<RequeueManyPurchasesResponse>
        | RequeueManyPurchasesResponse),
    options?: RequestHandlerOptions,
) => {
    return http.post(
        "*/purchases/requeue",
        async (info) => {
            return new HttpResponse(
                overrideResponse !== undefined
                    ? typeof overrideResponse === "function"
                        ? await overrideResponse(info)
                        : overrideResponse
                    : getRequeueManyPurchasesResponseMock(),
                {status: 200, headers: {"Content-Type": "text/plain"}},
            );
        },
        options,
    );
};

export const getRequeuePurchaseMockHandler = (
    overrideResponse?:
        | RequeuePurchaseResponse
        | ((
        info: Parameters<Parameters<typeof http.post>[1]>[0],
    ) => Promise<RequeuePurchaseResponse> | RequeuePurchaseResponse),
    options?: RequestHandlerOptions,
) => {
    return http.post(
        "*/purchases/:id/requeue",
        async (info) => {
            return new HttpResponse(
                overrideResponse !== undefined
                    ? typeof overrideResponse === "function"
                        ? await overrideResponse(info)
                        : overrideResponse
                    : getRequeuePurchaseResponseMock(),
                {status: 200, headers: {"Content-Type": "text/plain"}},
            );
        },
        options,
    );
};

export const getDeletePurchaseMockHandler = (
    overrideResponse?:
        | DeletePurchaseResponse
        | ((
        info: Parameters<Parameters<typeof http.delete>[1]>[0],
    ) => Promise<DeletePurchaseResponse> | DeletePurchaseResponse),
    options?: RequestHandlerOptions,
) => {
    return http.delete(
        "*/purchases/:id",
        async (info) => {
            return new HttpResponse(
                overrideResponse !== undefined
                    ? typeof overrideResponse === "function"
                        ? await overrideResponse(info)
                        : overrideResponse
                    : getDeletePurchaseResponseMock(),
                {status: 200, headers: {"Content-Type": "text/plain"}},
            );
        },
        options,
    );
};
export const getPurchasesMock = () => [
    getListPurchasesMockHandler(),
    getDeleteManyPurchasesMockHandler(),
    getCreatePurchaseMockHandler(),
    getRequeueManyPurchasesMockHandler(),
    getRequeuePurchaseMockHandler(),
    getDeletePurchaseMockHandler(),
];
