/**
 * Generated by orval v8.2.0 ðŸº
 * Do not edit manually.
 * MyMusic.Server | v1
 * OpenAPI spec version: 1.0.0
 */

import {faker} from "@faker-js/faker";
import type {
    DataTag,
    DefinedInitialDataOptions,
    DefinedUseQueryResult,
    InvalidateOptions,
    MutationFunction,
    QueryClient,
    QueryFunction,
    QueryKey,
    UndefinedInitialDataOptions,
    UseMutationOptions,
    UseMutationResult,
    UseQueryOptions,
    UseQueryResult,
} from "@tanstack/react-query";
import {useMutation, useQuery, useQueryClient} from "@tanstack/react-query";
import type {RequestHandlerOptions} from "msw";
import {http, HttpResponse} from "msw";
import type {
    FilterMetadataResponse,
    FilterValuesResponse,
    GetSongDevicesResponse,
    GetSongFilterValuesParams,
    GetSongResponse,
    ImportSongsBody,
    ListSongsParams,
    ListSongsResponse,
    ToggleFavoriteResponse,
    ToggleFavoritesRequest,
    ToggleFavoritesResponse,
    UpdateSongDevicesRequest,
    UpdateSongDevicesResponse,
} from "../model";

export type listSongsResponse200 = {
    data: ListSongsResponse;
    status: 200;
};

export type listSongsResponseSuccess = listSongsResponse200 & {
    headers: Headers;
};

export type listSongsResponse = listSongsResponseSuccess;

export const getListSongsUrl = (params?: ListSongsParams) => {
    const normalizedParams = new URLSearchParams();

    Object.entries(params || {}).forEach(([key, value]) => {
        if (value !== undefined) {
            normalizedParams.append(key, value === null ? "null" : value.toString());
        }
    });

    const stringifiedParams = normalizedParams.toString();

    return stringifiedParams.length > 0
        ? `/api/songs?${stringifiedParams}`
        : `/api/songs`;
};

export const listSongs = async (
    params?: ListSongsParams,
    options?: RequestInit,
): Promise<listSongsResponse> => {
    const res = await fetch(getListSongsUrl(params), {
        ...options,
        method: "GET",
    });

    const body = [204, 205, 304].includes(res.status) ? null : await res.text();

    const data: listSongsResponse["data"] = body ? JSON.parse(body) : {};
    return {
        data,
        status: res.status,
        headers: res.headers,
    } as listSongsResponse;
};

export const getListSongsQueryKey = (params?: ListSongsParams) => {
    return ["api", "songs", ...(params ? [params] : [])] as const;
};

export const getListSongsQueryOptions = <
    TData = Awaited<ReturnType<typeof listSongs>>,
    TError = unknown,
>(
    params?: ListSongsParams,
    options?: {
        query?: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof listSongs>>, TError, TData>
        >;
        fetch?: RequestInit;
    },
) => {
    const {query: queryOptions, fetch: fetchOptions} = options ?? {};

    const queryKey = queryOptions?.queryKey ?? getListSongsQueryKey(params);

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listSongs>>> = ({
                                                                               signal,
                                                                           }) => listSongs(params, {signal, ...fetchOptions});

    return {queryKey, queryFn, ...queryOptions} as UseQueryOptions<
        Awaited<ReturnType<typeof listSongs>>,
        TError,
        TData
    > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ListSongsQueryResult = NonNullable<
    Awaited<ReturnType<typeof listSongs>>
>;
export type ListSongsQueryError = unknown;

export function useListSongs<
    TData = Awaited<ReturnType<typeof listSongs>>,
    TError = unknown,
>(
    params: undefined | ListSongsParams,
    options: {
        query: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof listSongs>>, TError, TData>
        > &
            Pick<
                DefinedInitialDataOptions<
                    Awaited<ReturnType<typeof listSongs>>,
                    TError,
                    Awaited<ReturnType<typeof listSongs>>
                >,
                "initialData"
            >;
        fetch?: RequestInit;
    },
    queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useListSongs<
    TData = Awaited<ReturnType<typeof listSongs>>,
    TError = unknown,
>(
    params?: ListSongsParams,
    options?: {
        query?: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof listSongs>>, TError, TData>
        > &
            Pick<
                UndefinedInitialDataOptions<
                    Awaited<ReturnType<typeof listSongs>>,
                    TError,
                    Awaited<ReturnType<typeof listSongs>>
                >,
                "initialData"
            >;
        fetch?: RequestInit;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useListSongs<
    TData = Awaited<ReturnType<typeof listSongs>>,
    TError = unknown,
>(
    params?: ListSongsParams,
    options?: {
        query?: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof listSongs>>, TError, TData>
        >;
        fetch?: RequestInit;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};

export function useListSongs<
    TData = Awaited<ReturnType<typeof listSongs>>,
    TError = unknown,
>(
    params?: ListSongsParams,
    options?: {
        query?: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof listSongs>>, TError, TData>
        >;
        fetch?: RequestInit;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
} {
    const queryOptions = getListSongsQueryOptions(params, options);

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<
        TData,
        TError
    > & { queryKey: DataTag<QueryKey, TData, TError> };

    return {...query, queryKey: queryOptions.queryKey};
}

export const invalidateListSongs = async (
    queryClient: QueryClient,
    params?: ListSongsParams,
    options?: InvalidateOptions,
): Promise<QueryClient> => {
    await queryClient.invalidateQueries(
        {queryKey: getListSongsQueryKey(params)},
        options,
    );

    return queryClient;
};

export type getSongResponse200 = {
    data: GetSongResponse;
    status: 200;
};

export type getSongResponseSuccess = getSongResponse200 & {
    headers: Headers;
};

export type getSongResponse = getSongResponseSuccess;

export const getGetSongUrl = (id: number) => {
    return `/api/songs/${id}`;
};

export const getSong = async (
    id: number,
    options?: RequestInit,
): Promise<getSongResponse> => {
    const res = await fetch(getGetSongUrl(id), {
        ...options,
        method: "GET",
    });

    const body = [204, 205, 304].includes(res.status) ? null : await res.text();

    const data: getSongResponse["data"] = body ? JSON.parse(body) : {};
    return {data, status: res.status, headers: res.headers} as getSongResponse;
};

export const getGetSongQueryKey = (id: number) => {
    return ["api", "songs", id] as const;
};

export const getGetSongQueryOptions = <
    TData = Awaited<ReturnType<typeof getSong>>,
    TError = unknown,
>(
    id: number,
    options?: {
        query?: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof getSong>>, TError, TData>
        >;
        fetch?: RequestInit;
    },
) => {
    const {query: queryOptions, fetch: fetchOptions} = options ?? {};

    const queryKey = queryOptions?.queryKey ?? getGetSongQueryKey(id);

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSong>>> = ({
                                                                             signal,
                                                                         }) => getSong(id, {signal, ...fetchOptions});

    return {
        queryKey,
        queryFn,
        enabled: !!id,
        ...queryOptions,
    } as UseQueryOptions<Awaited<ReturnType<typeof getSong>>, TError, TData> & {
        queryKey: DataTag<QueryKey, TData, TError>;
    };
};

export type GetSongQueryResult = NonNullable<
    Awaited<ReturnType<typeof getSong>>
>;
export type GetSongQueryError = unknown;

export function useGetSong<
    TData = Awaited<ReturnType<typeof getSong>>,
    TError = unknown,
>(
    id: number,
    options: {
        query: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof getSong>>, TError, TData>
        > &
            Pick<
                DefinedInitialDataOptions<
                    Awaited<ReturnType<typeof getSong>>,
                    TError,
                    Awaited<ReturnType<typeof getSong>>
                >,
                "initialData"
            >;
        fetch?: RequestInit;
    },
    queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSong<
    TData = Awaited<ReturnType<typeof getSong>>,
    TError = unknown,
>(
    id: number,
    options?: {
        query?: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof getSong>>, TError, TData>
        > &
            Pick<
                UndefinedInitialDataOptions<
                    Awaited<ReturnType<typeof getSong>>,
                    TError,
                    Awaited<ReturnType<typeof getSong>>
                >,
                "initialData"
            >;
        fetch?: RequestInit;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSong<
    TData = Awaited<ReturnType<typeof getSong>>,
    TError = unknown,
>(
    id: number,
    options?: {
        query?: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof getSong>>, TError, TData>
        >;
        fetch?: RequestInit;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetSong<
    TData = Awaited<ReturnType<typeof getSong>>,
    TError = unknown,
>(
    id: number,
    options?: {
        query?: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof getSong>>, TError, TData>
        >;
        fetch?: RequestInit;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
} {
    const queryOptions = getGetSongQueryOptions(id, options);

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<
        TData,
        TError
    > & { queryKey: DataTag<QueryKey, TData, TError> };

    return {...query, queryKey: queryOptions.queryKey};
}

export const invalidateGetSong = async (
    queryClient: QueryClient,
    id: number,
    options?: InvalidateOptions,
): Promise<QueryClient> => {
    await queryClient.invalidateQueries(
        {queryKey: getGetSongQueryKey(id)},
        options,
    );

    return queryClient;
};

export type downloadSongResponse200 = {
    data: void;
    status: 200;
};

export type downloadSongResponseSuccess = downloadSongResponse200 & {
    headers: Headers;
};

export type downloadSongResponse = downloadSongResponseSuccess;

export const getDownloadSongUrl = (id: number) => {
    return `/api/songs/${id}/download`;
};

export const downloadSong = async (
    id: number,
    options?: RequestInit,
): Promise<downloadSongResponse> => {
    const res = await fetch(getDownloadSongUrl(id), {
        ...options,
        method: "GET",
    });

    const body = [204, 205, 304].includes(res.status) ? null : await res.text();

    const data: downloadSongResponse["data"] = body ? JSON.parse(body) : {};
    return {
        data,
        status: res.status,
        headers: res.headers,
    } as downloadSongResponse;
};

export const getDownloadSongQueryKey = (id: number) => {
    return ["api", "songs", id, "download"] as const;
};

export const getDownloadSongQueryOptions = <
    TData = Awaited<ReturnType<typeof downloadSong>>,
    TError = unknown,
>(
    id: number,
    options?: {
        query?: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof downloadSong>>, TError, TData>
        >;
        fetch?: RequestInit;
    },
) => {
    const {query: queryOptions, fetch: fetchOptions} = options ?? {};

    const queryKey = queryOptions?.queryKey ?? getDownloadSongQueryKey(id);

    const queryFn: QueryFunction<Awaited<ReturnType<typeof downloadSong>>> = ({
                                                                                  signal,
                                                                              }) => downloadSong(id, {signal, ...fetchOptions});

    return {
        queryKey,
        queryFn,
        enabled: !!id,
        ...queryOptions,
    } as UseQueryOptions<
        Awaited<ReturnType<typeof downloadSong>>,
        TError,
        TData
    > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type DownloadSongQueryResult = NonNullable<
    Awaited<ReturnType<typeof downloadSong>>
>;
export type DownloadSongQueryError = unknown;

export function useDownloadSong<
    TData = Awaited<ReturnType<typeof downloadSong>>,
    TError = unknown,
>(
    id: number,
    options: {
        query: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof downloadSong>>, TError, TData>
        > &
            Pick<
                DefinedInitialDataOptions<
                    Awaited<ReturnType<typeof downloadSong>>,
                    TError,
                    Awaited<ReturnType<typeof downloadSong>>
                >,
                "initialData"
            >;
        fetch?: RequestInit;
    },
    queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useDownloadSong<
    TData = Awaited<ReturnType<typeof downloadSong>>,
    TError = unknown,
>(
    id: number,
    options?: {
        query?: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof downloadSong>>, TError, TData>
        > &
            Pick<
                UndefinedInitialDataOptions<
                    Awaited<ReturnType<typeof downloadSong>>,
                    TError,
                    Awaited<ReturnType<typeof downloadSong>>
                >,
                "initialData"
            >;
        fetch?: RequestInit;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useDownloadSong<
    TData = Awaited<ReturnType<typeof downloadSong>>,
    TError = unknown,
>(
    id: number,
    options?: {
        query?: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof downloadSong>>, TError, TData>
        >;
        fetch?: RequestInit;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};

export function useDownloadSong<
    TData = Awaited<ReturnType<typeof downloadSong>>,
    TError = unknown,
>(
    id: number,
    options?: {
        query?: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof downloadSong>>, TError, TData>
        >;
        fetch?: RequestInit;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
} {
    const queryOptions = getDownloadSongQueryOptions(id, options);

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<
        TData,
        TError
    > & { queryKey: DataTag<QueryKey, TData, TError> };

    return {...query, queryKey: queryOptions.queryKey};
}

export const invalidateDownloadSong = async (
    queryClient: QueryClient,
    id: number,
    options?: InvalidateOptions,
): Promise<QueryClient> => {
    await queryClient.invalidateQueries(
        {queryKey: getDownloadSongQueryKey(id)},
        options,
    );

    return queryClient;
};

export type importSongsResponse200 = {
    data: void;
    status: 200;
};

export type importSongsResponseSuccess = importSongsResponse200 & {
    headers: Headers;
};

export type importSongsResponse = importSongsResponseSuccess;

export const getImportSongsUrl = () => {
    return `/api/songs/import`;
};

export const importSongs = async (
    importSongsBody: ImportSongsBody,
    options?: RequestInit,
): Promise<importSongsResponse> => {
    const formUrlEncoded = new URLSearchParams();
    if (importSongsBody.sourceFolder !== undefined) {
        formUrlEncoded.append(`sourceFolder`, importSongsBody.sourceFolder);
    }

    const res = await fetch(getImportSongsUrl(), {
        ...options,
        method: "POST",
        headers: {
            "Content-Type": "application/x-www-form-urlencoded",
            ...options?.headers,
        },
        body: formUrlEncoded,
    });

    const body = [204, 205, 304].includes(res.status) ? null : await res.text();

    const data: importSongsResponse["data"] = body ? JSON.parse(body) : {};
    return {
        data,
        status: res.status,
        headers: res.headers,
    } as importSongsResponse;
};

export const getImportSongsMutationOptions = <
    TError = unknown,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof importSongs>>,
        TError,
        { data: ImportSongsBody },
        TContext
    >;
    fetch?: RequestInit;
}): UseMutationOptions<
    Awaited<ReturnType<typeof importSongs>>,
    TError,
    { data: ImportSongsBody },
    TContext
> => {
    const mutationKey = ["importSongs"];
    const {mutation: mutationOptions, fetch: fetchOptions} = options
        ? options.mutation &&
        "mutationKey" in options.mutation &&
        options.mutation.mutationKey
            ? options
            : {...options, mutation: {...options.mutation, mutationKey}}
        : {mutation: {mutationKey}, fetch: undefined};

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof importSongs>>,
        { data: ImportSongsBody }
    > = (props) => {
        const {data} = props ?? {};

        return importSongs(data, fetchOptions);
    };

    return {mutationFn, ...mutationOptions};
};

export type ImportSongsMutationResult = NonNullable<
    Awaited<ReturnType<typeof importSongs>>
>;
export type ImportSongsMutationBody = ImportSongsBody;
export type ImportSongsMutationError = unknown;

export const useImportSongs = <TError = unknown, TContext = unknown>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof importSongs>>,
            TError,
            { data: ImportSongsBody },
            TContext
        >;
        fetch?: RequestInit;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof importSongs>>,
    TError,
    { data: ImportSongsBody },
    TContext
> => {
    return useMutation(getImportSongsMutationOptions(options), queryClient);
};
export type toggleSongFavoriteResponse200 = {
    data: ToggleFavoriteResponse;
    status: 200;
};

export type toggleSongFavoriteResponseSuccess =
    toggleSongFavoriteResponse200 & {
    headers: Headers;
};

export type toggleSongFavoriteResponse = toggleSongFavoriteResponseSuccess;

export const getToggleSongFavoriteUrl = (id: number) => {
    return `/api/songs/${id}/favorite`;
};

export const toggleSongFavorite = async (
    id: number,
    options?: RequestInit,
): Promise<toggleSongFavoriteResponse> => {
    const res = await fetch(getToggleSongFavoriteUrl(id), {
        ...options,
        method: "POST",
    });

    const body = [204, 205, 304].includes(res.status) ? null : await res.text();

    const data: toggleSongFavoriteResponse["data"] = body ? JSON.parse(body) : {};
    return {
        data,
        status: res.status,
        headers: res.headers,
    } as toggleSongFavoriteResponse;
};

export const getToggleSongFavoriteMutationOptions = <
    TError = unknown,
    TContext = unknown,
>(
    queryClient: QueryClient,
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof toggleSongFavorite>>,
            TError,
            { id: number },
            TContext
        >;
        fetch?: RequestInit;
    },
): UseMutationOptions<
    Awaited<ReturnType<typeof toggleSongFavorite>>,
    TError,
    { id: number },
    TContext
> => {
    const mutationKey = ["toggleSongFavorite"];
    const {mutation: mutationOptions, fetch: fetchOptions} = options
        ? options.mutation &&
        "mutationKey" in options.mutation &&
        options.mutation.mutationKey
            ? options
            : {...options, mutation: {...options.mutation, mutationKey}}
        : {mutation: {mutationKey}, fetch: undefined};

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof toggleSongFavorite>>,
        { id: number }
    > = (props) => {
        const {id} = props ?? {};

        return toggleSongFavorite(id, fetchOptions);
    };

    const onSuccess = (
        data: Awaited<ReturnType<typeof toggleSongFavorite>>,
        variables: { id: number },
        context: TContext,
    ) => {
        queryClient.invalidateQueries({queryKey: getListSongsQueryKey()});
        queryClient.invalidateQueries({queryKey: getGetSongQueryKey()});
        mutationOptions?.onSuccess?.(data, variables, context);
    };

    return {mutationFn, onSuccess, ...mutationOptions};
};

export type ToggleSongFavoriteMutationResult = NonNullable<
    Awaited<ReturnType<typeof toggleSongFavorite>>
>;

export type ToggleSongFavoriteMutationError = unknown;

export const useToggleSongFavorite = <TError = unknown, TContext = unknown>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof toggleSongFavorite>>,
            TError,
            { id: number },
            TContext
        >;
        fetch?: RequestInit;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof toggleSongFavorite>>,
    TError,
    { id: number },
    TContext
> => {
    const backupQueryClient = useQueryClient();
    return useMutation(
        getToggleSongFavoriteMutationOptions(
            queryClient ?? backupQueryClient,
            options,
        ),
        queryClient,
    );
};
export type toggleFavoritesResponse200 = {
    data: ToggleFavoritesResponse;
    status: 200;
};

export type toggleFavoritesResponseSuccess = toggleFavoritesResponse200 & {
    headers: Headers;
};

export type toggleFavoritesResponse = toggleFavoritesResponseSuccess;

export const getToggleFavoritesUrl = () => {
    return `/api/songs/favorites`;
};

export const toggleFavorites = async (
    toggleFavoritesRequest: ToggleFavoritesRequest,
    options?: RequestInit,
): Promise<toggleFavoritesResponse> => {
    const res = await fetch(getToggleFavoritesUrl(), {
        ...options,
        method: "POST",
        headers: {"Content-Type": "application/json", ...options?.headers},
        body: JSON.stringify(toggleFavoritesRequest),
    });

    const body = [204, 205, 304].includes(res.status) ? null : await res.text();

    const data: toggleFavoritesResponse["data"] = body ? JSON.parse(body) : {};
    return {
        data,
        status: res.status,
        headers: res.headers,
    } as toggleFavoritesResponse;
};

export const getToggleFavoritesMutationOptions = <
    TError = unknown,
    TContext = unknown,
>(
    queryClient: QueryClient,
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof toggleFavorites>>,
            TError,
            { data: ToggleFavoritesRequest },
            TContext
        >;
        fetch?: RequestInit;
    },
): UseMutationOptions<
    Awaited<ReturnType<typeof toggleFavorites>>,
    TError,
    { data: ToggleFavoritesRequest },
    TContext
> => {
    const mutationKey = ["toggleFavorites"];
    const {mutation: mutationOptions, fetch: fetchOptions} = options
        ? options.mutation &&
        "mutationKey" in options.mutation &&
        options.mutation.mutationKey
            ? options
            : {...options, mutation: {...options.mutation, mutationKey}}
        : {mutation: {mutationKey}, fetch: undefined};

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof toggleFavorites>>,
        { data: ToggleFavoritesRequest }
    > = (props) => {
        const {data} = props ?? {};

        return toggleFavorites(data, fetchOptions);
    };

    const onSuccess = (
        data: Awaited<ReturnType<typeof toggleFavorites>>,
        variables: { data: ToggleFavoritesRequest },
        context: TContext,
    ) => {
        queryClient.invalidateQueries({queryKey: getListSongsQueryKey()});
        queryClient.invalidateQueries({queryKey: getGetSongQueryKey()});
        mutationOptions?.onSuccess?.(data, variables, context);
    };

    return {mutationFn, onSuccess, ...mutationOptions};
};

export type ToggleFavoritesMutationResult = NonNullable<
    Awaited<ReturnType<typeof toggleFavorites>>
>;
export type ToggleFavoritesMutationBody = ToggleFavoritesRequest;
export type ToggleFavoritesMutationError = unknown;

export const useToggleFavorites = <TError = unknown, TContext = unknown>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof toggleFavorites>>,
            TError,
            { data: ToggleFavoritesRequest },
            TContext
        >;
        fetch?: RequestInit;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof toggleFavorites>>,
    TError,
    { data: ToggleFavoritesRequest },
    TContext
> => {
    const backupQueryClient = useQueryClient();
    return useMutation(
        getToggleFavoritesMutationOptions(
            queryClient ?? backupQueryClient,
            options,
        ),
        queryClient,
    );
};
export type getSongDevicesResponse200 = {
    data: GetSongDevicesResponse;
    status: 200;
};

export type getSongDevicesResponseSuccess = getSongDevicesResponse200 & {
    headers: Headers;
};

export type getSongDevicesResponse = getSongDevicesResponseSuccess;

export const getGetSongDevicesUrl = (id: number) => {
    return `/api/songs/${id}/devices`;
};

export const getSongDevices = async (
    id: number,
    options?: RequestInit,
): Promise<getSongDevicesResponse> => {
    const res = await fetch(getGetSongDevicesUrl(id), {
        ...options,
        method: "GET",
    });

    const body = [204, 205, 304].includes(res.status) ? null : await res.text();

    const data: getSongDevicesResponse["data"] = body ? JSON.parse(body) : {};
    return {
        data,
        status: res.status,
        headers: res.headers,
    } as getSongDevicesResponse;
};

export const getGetSongDevicesQueryKey = (id: number) => {
    return ["api", "songs", id, "devices"] as const;
};

export const getGetSongDevicesQueryOptions = <
    TData = Awaited<ReturnType<typeof getSongDevices>>,
    TError = unknown,
>(
    id: number,
    options?: {
        query?: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof getSongDevices>>, TError, TData>
        >;
        fetch?: RequestInit;
    },
) => {
    const {query: queryOptions, fetch: fetchOptions} = options ?? {};

    const queryKey = queryOptions?.queryKey ?? getGetSongDevicesQueryKey(id);

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSongDevices>>> = ({
                                                                                    signal,
                                                                                }) => getSongDevices(id, {signal, ...fetchOptions});

    return {
        queryKey,
        queryFn,
        enabled: !!id,
        ...queryOptions,
    } as UseQueryOptions<
        Awaited<ReturnType<typeof getSongDevices>>,
        TError,
        TData
    > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetSongDevicesQueryResult = NonNullable<
    Awaited<ReturnType<typeof getSongDevices>>
>;
export type GetSongDevicesQueryError = unknown;

export function useGetSongDevices<
    TData = Awaited<ReturnType<typeof getSongDevices>>,
    TError = unknown,
>(
    id: number,
    options: {
        query: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof getSongDevices>>, TError, TData>
        > &
            Pick<
                DefinedInitialDataOptions<
                    Awaited<ReturnType<typeof getSongDevices>>,
                    TError,
                    Awaited<ReturnType<typeof getSongDevices>>
                >,
                "initialData"
            >;
        fetch?: RequestInit;
    },
    queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSongDevices<
    TData = Awaited<ReturnType<typeof getSongDevices>>,
    TError = unknown,
>(
    id: number,
    options?: {
        query?: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof getSongDevices>>, TError, TData>
        > &
            Pick<
                UndefinedInitialDataOptions<
                    Awaited<ReturnType<typeof getSongDevices>>,
                    TError,
                    Awaited<ReturnType<typeof getSongDevices>>
                >,
                "initialData"
            >;
        fetch?: RequestInit;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSongDevices<
    TData = Awaited<ReturnType<typeof getSongDevices>>,
    TError = unknown,
>(
    id: number,
    options?: {
        query?: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof getSongDevices>>, TError, TData>
        >;
        fetch?: RequestInit;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetSongDevices<
    TData = Awaited<ReturnType<typeof getSongDevices>>,
    TError = unknown,
>(
    id: number,
    options?: {
        query?: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof getSongDevices>>, TError, TData>
        >;
        fetch?: RequestInit;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
} {
    const queryOptions = getGetSongDevicesQueryOptions(id, options);

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<
        TData,
        TError
    > & { queryKey: DataTag<QueryKey, TData, TError> };

    return {...query, queryKey: queryOptions.queryKey};
}

export const invalidateGetSongDevices = async (
    queryClient: QueryClient,
    id: number,
    options?: InvalidateOptions,
): Promise<QueryClient> => {
    await queryClient.invalidateQueries(
        {queryKey: getGetSongDevicesQueryKey(id)},
        options,
    );

    return queryClient;
};

export type updateSongDevicesResponse200 = {
    data: UpdateSongDevicesResponse;
    status: 200;
};

export type updateSongDevicesResponseSuccess = updateSongDevicesResponse200 & {
    headers: Headers;
};

export type updateSongDevicesResponse = updateSongDevicesResponseSuccess;

export const getUpdateSongDevicesUrl = () => {
    return `/api/songs/devices`;
};

export const updateSongDevices = async (
    updateSongDevicesRequest: UpdateSongDevicesRequest,
    options?: RequestInit,
): Promise<updateSongDevicesResponse> => {
    const res = await fetch(getUpdateSongDevicesUrl(), {
        ...options,
        method: "PUT",
        headers: {"Content-Type": "application/json", ...options?.headers},
        body: JSON.stringify(updateSongDevicesRequest),
    });

    const body = [204, 205, 304].includes(res.status) ? null : await res.text();

    const data: updateSongDevicesResponse["data"] = body ? JSON.parse(body) : {};
    return {
        data,
        status: res.status,
        headers: res.headers,
    } as updateSongDevicesResponse;
};

export const getUpdateSongDevicesMutationOptions = <
    TError = unknown,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof updateSongDevices>>,
        TError,
        { data: UpdateSongDevicesRequest },
        TContext
    >;
    fetch?: RequestInit;
}): UseMutationOptions<
    Awaited<ReturnType<typeof updateSongDevices>>,
    TError,
    { data: UpdateSongDevicesRequest },
    TContext
> => {
    const mutationKey = ["updateSongDevices"];
    const {mutation: mutationOptions, fetch: fetchOptions} = options
        ? options.mutation &&
        "mutationKey" in options.mutation &&
        options.mutation.mutationKey
            ? options
            : {...options, mutation: {...options.mutation, mutationKey}}
        : {mutation: {mutationKey}, fetch: undefined};

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof updateSongDevices>>,
        { data: UpdateSongDevicesRequest }
    > = (props) => {
        const {data} = props ?? {};

        return updateSongDevices(data, fetchOptions);
    };

    return {mutationFn, ...mutationOptions};
};

export type UpdateSongDevicesMutationResult = NonNullable<
    Awaited<ReturnType<typeof updateSongDevices>>
>;
export type UpdateSongDevicesMutationBody = UpdateSongDevicesRequest;
export type UpdateSongDevicesMutationError = unknown;

export const useUpdateSongDevices = <TError = unknown, TContext = unknown>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof updateSongDevices>>,
            TError,
            { data: UpdateSongDevicesRequest },
            TContext
        >;
        fetch?: RequestInit;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof updateSongDevices>>,
    TError,
    { data: UpdateSongDevicesRequest },
    TContext
> => {
    return useMutation(getUpdateSongDevicesMutationOptions(options), queryClient);
};
export type getSongFilterMetadataResponse200 = {
    data: FilterMetadataResponse;
    status: 200;
};

export type getSongFilterMetadataResponseSuccess =
    getSongFilterMetadataResponse200 & {
    headers: Headers;
};

export type getSongFilterMetadataResponse =
    getSongFilterMetadataResponseSuccess;

export const getGetSongFilterMetadataUrl = () => {
    return `/api/songs/filter-metadata`;
};

export const getSongFilterMetadata = async (
    options?: RequestInit,
): Promise<getSongFilterMetadataResponse> => {
    const res = await fetch(getGetSongFilterMetadataUrl(), {
        ...options,
        method: "GET",
    });

    const body = [204, 205, 304].includes(res.status) ? null : await res.text();

    const data: getSongFilterMetadataResponse["data"] = body
        ? JSON.parse(body)
        : {};
    return {
        data,
        status: res.status,
        headers: res.headers,
    } as getSongFilterMetadataResponse;
};

export const getGetSongFilterMetadataQueryKey = () => {
    return ["api", "songs", "filter-metadata"] as const;
};

export const getGetSongFilterMetadataQueryOptions = <
    TData = Awaited<ReturnType<typeof getSongFilterMetadata>>,
    TError = unknown,
>(options?: {
    query?: Partial<
        UseQueryOptions<
            Awaited<ReturnType<typeof getSongFilterMetadata>>,
            TError,
            TData
        >
    >;
    fetch?: RequestInit;
}) => {
    const {query: queryOptions, fetch: fetchOptions} = options ?? {};

    const queryKey = queryOptions?.queryKey ?? getGetSongFilterMetadataQueryKey();

    const queryFn: QueryFunction<
        Awaited<ReturnType<typeof getSongFilterMetadata>>
    > = ({signal}) => getSongFilterMetadata({signal, ...fetchOptions});

    return {queryKey, queryFn, ...queryOptions} as UseQueryOptions<
        Awaited<ReturnType<typeof getSongFilterMetadata>>,
        TError,
        TData
    > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetSongFilterMetadataQueryResult = NonNullable<
    Awaited<ReturnType<typeof getSongFilterMetadata>>
>;
export type GetSongFilterMetadataQueryError = unknown;

export function useGetSongFilterMetadata<
    TData = Awaited<ReturnType<typeof getSongFilterMetadata>>,
    TError = unknown,
>(
    options: {
        query: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getSongFilterMetadata>>,
                TError,
                TData
            >
        > &
            Pick<
                DefinedInitialDataOptions<
                    Awaited<ReturnType<typeof getSongFilterMetadata>>,
                    TError,
                    Awaited<ReturnType<typeof getSongFilterMetadata>>
                >,
                "initialData"
            >;
        fetch?: RequestInit;
    },
    queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSongFilterMetadata<
    TData = Awaited<ReturnType<typeof getSongFilterMetadata>>,
    TError = unknown,
>(
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getSongFilterMetadata>>,
                TError,
                TData
            >
        > &
            Pick<
                UndefinedInitialDataOptions<
                    Awaited<ReturnType<typeof getSongFilterMetadata>>,
                    TError,
                    Awaited<ReturnType<typeof getSongFilterMetadata>>
                >,
                "initialData"
            >;
        fetch?: RequestInit;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSongFilterMetadata<
    TData = Awaited<ReturnType<typeof getSongFilterMetadata>>,
    TError = unknown,
>(
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getSongFilterMetadata>>,
                TError,
                TData
            >
        >;
        fetch?: RequestInit;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetSongFilterMetadata<
    TData = Awaited<ReturnType<typeof getSongFilterMetadata>>,
    TError = unknown,
>(
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getSongFilterMetadata>>,
                TError,
                TData
            >
        >;
        fetch?: RequestInit;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
} {
    const queryOptions = getGetSongFilterMetadataQueryOptions(options);

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<
        TData,
        TError
    > & { queryKey: DataTag<QueryKey, TData, TError> };

    return {...query, queryKey: queryOptions.queryKey};
}

export const invalidateGetSongFilterMetadata = async (
    queryClient: QueryClient,
    options?: InvalidateOptions,
): Promise<QueryClient> => {
    await queryClient.invalidateQueries(
        {queryKey: getGetSongFilterMetadataQueryKey()},
        options,
    );

    return queryClient;
};

export type getSongFilterValuesResponse200 = {
    data: FilterValuesResponse;
    status: 200;
};

export type getSongFilterValuesResponseSuccess =
    getSongFilterValuesResponse200 & {
    headers: Headers;
};

export type getSongFilterValuesResponse = getSongFilterValuesResponseSuccess;

export const getGetSongFilterValuesUrl = (
    params?: GetSongFilterValuesParams,
) => {
    const normalizedParams = new URLSearchParams();

    Object.entries(params || {}).forEach(([key, value]) => {
        if (value !== undefined) {
            normalizedParams.append(key, value === null ? "null" : value.toString());
        }
    });

    const stringifiedParams = normalizedParams.toString();

    return stringifiedParams.length > 0
        ? `/api/songs/filter-values?${stringifiedParams}`
        : `/api/songs/filter-values`;
};

export const getSongFilterValues = async (
    params?: GetSongFilterValuesParams,
    options?: RequestInit,
): Promise<getSongFilterValuesResponse> => {
    const res = await fetch(getGetSongFilterValuesUrl(params), {
        ...options,
        method: "GET",
    });

    const body = [204, 205, 304].includes(res.status) ? null : await res.text();

    const data: getSongFilterValuesResponse["data"] = body
        ? JSON.parse(body)
        : {};
    return {
        data,
        status: res.status,
        headers: res.headers,
    } as getSongFilterValuesResponse;
};

export const getGetSongFilterValuesQueryKey = (
    params?: GetSongFilterValuesParams,
) => {
    return [
        "api",
        "songs",
        "filter-values",
        ...(params ? [params] : []),
    ] as const;
};

export const getGetSongFilterValuesQueryOptions = <
    TData = Awaited<ReturnType<typeof getSongFilterValues>>,
    TError = unknown,
>(
    params?: GetSongFilterValuesParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getSongFilterValues>>,
                TError,
                TData
            >
        >;
        fetch?: RequestInit;
    },
) => {
    const {query: queryOptions, fetch: fetchOptions} = options ?? {};

    const queryKey =
        queryOptions?.queryKey ?? getGetSongFilterValuesQueryKey(params);

    const queryFn: QueryFunction<
        Awaited<ReturnType<typeof getSongFilterValues>>
    > = ({signal}) => getSongFilterValues(params, {signal, ...fetchOptions});

    return {queryKey, queryFn, ...queryOptions} as UseQueryOptions<
        Awaited<ReturnType<typeof getSongFilterValues>>,
        TError,
        TData
    > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetSongFilterValuesQueryResult = NonNullable<
    Awaited<ReturnType<typeof getSongFilterValues>>
>;
export type GetSongFilterValuesQueryError = unknown;

export function useGetSongFilterValues<
    TData = Awaited<ReturnType<typeof getSongFilterValues>>,
    TError = unknown,
>(
    params: undefined | GetSongFilterValuesParams,
    options: {
        query: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getSongFilterValues>>,
                TError,
                TData
            >
        > &
            Pick<
                DefinedInitialDataOptions<
                    Awaited<ReturnType<typeof getSongFilterValues>>,
                    TError,
                    Awaited<ReturnType<typeof getSongFilterValues>>
                >,
                "initialData"
            >;
        fetch?: RequestInit;
    },
    queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSongFilterValues<
    TData = Awaited<ReturnType<typeof getSongFilterValues>>,
    TError = unknown,
>(
    params?: GetSongFilterValuesParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getSongFilterValues>>,
                TError,
                TData
            >
        > &
            Pick<
                UndefinedInitialDataOptions<
                    Awaited<ReturnType<typeof getSongFilterValues>>,
                    TError,
                    Awaited<ReturnType<typeof getSongFilterValues>>
                >,
                "initialData"
            >;
        fetch?: RequestInit;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSongFilterValues<
    TData = Awaited<ReturnType<typeof getSongFilterValues>>,
    TError = unknown,
>(
    params?: GetSongFilterValuesParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getSongFilterValues>>,
                TError,
                TData
            >
        >;
        fetch?: RequestInit;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetSongFilterValues<
    TData = Awaited<ReturnType<typeof getSongFilterValues>>,
    TError = unknown,
>(
    params?: GetSongFilterValuesParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getSongFilterValues>>,
                TError,
                TData
            >
        >;
        fetch?: RequestInit;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
} {
    const queryOptions = getGetSongFilterValuesQueryOptions(params, options);

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<
        TData,
        TError
    > & { queryKey: DataTag<QueryKey, TData, TError> };

    return {...query, queryKey: queryOptions.queryKey};
}

export const invalidateGetSongFilterValues = async (
    queryClient: QueryClient,
    params?: GetSongFilterValuesParams,
    options?: InvalidateOptions,
): Promise<QueryClient> => {
    await queryClient.invalidateQueries(
        {queryKey: getGetSongFilterValuesQueryKey(params)},
        options,
    );

    return queryClient;
};

export const getListSongsResponseMock = (
    overrideResponse: Partial<ListSongsResponse> = {},
): ListSongsResponse => ({
    songs: Array.from(
        {length: faker.number.int({min: 1, max: 10})},
        (_, i) => i + 1,
    ).map(() => ({
        id: faker.number.int({min: undefined, max: undefined}),
        cover: faker.helpers.arrayElement([
            faker.helpers.arrayElement([
                faker.number.int({min: undefined, max: undefined}),
                null,
            ]),
            null,
        ]),
        title: faker.string.alpha({length: {min: 10, max: 20}}),
        artists: Array.from(
            {length: faker.number.int({min: 1, max: 10})},
            (_, i) => i + 1,
        ).map(() => ({
            id: faker.number.int({min: undefined, max: undefined}),
            name: faker.string.alpha({length: {min: 10, max: 20}}),
        })),
        album: {
            id: faker.number.int({min: undefined, max: undefined}),
            name: faker.string.alpha({length: {min: 10, max: 20}}),
        },
        genres: Array.from(
            {length: faker.number.int({min: 1, max: 10})},
            (_, i) => i + 1,
        ).map(() => ({
            id: faker.number.int({min: undefined, max: undefined}),
            name: faker.string.alpha({length: {min: 10, max: 20}}),
        })),
        year: faker.helpers.arrayElement([
            faker.helpers.arrayElement([
                faker.number.int({min: undefined, max: undefined}),
                null,
            ]),
            null,
        ]),
        duration: faker.string.alpha({length: {min: 10, max: 20}}),
        isFavorite: faker.datatype.boolean(),
        isExplicit: faker.datatype.boolean(),
        createdAt: faker.date.past().toISOString().slice(0, 19) + "Z",
        addedAt: faker.helpers.arrayElement([
            faker.helpers.arrayElement([
                faker.date.past().toISOString().slice(0, 19) + "Z",
                null,
            ]),
            undefined,
        ]),
    })),
    ...overrideResponse,
});

export const getGetSongResponseMock = (
    overrideResponse: Partial<GetSongResponse> = {},
): GetSongResponse => ({
    song: {
        id: faker.number.int({min: undefined, max: undefined}),
        cover: faker.helpers.arrayElement([
            faker.helpers.arrayElement([
                faker.number.int({min: undefined, max: undefined}),
                null,
            ]),
            null,
        ]),
        title: faker.string.alpha({length: {min: 10, max: 20}}),
        label: faker.string.alpha({length: {min: 10, max: 20}}),
        artists: Array.from(
            {length: faker.number.int({min: 1, max: 10})},
            (_, i) => i + 1,
        ).map(() => ({
            id: faker.number.int({min: undefined, max: undefined}),
            name: faker.string.alpha({length: {min: 10, max: 20}}),
        })),
        album: {
            id: faker.number.int({min: undefined, max: undefined}),
            name: faker.string.alpha({length: {min: 10, max: 20}}),
            year: faker.helpers.arrayElement([
                faker.helpers.arrayElement([
                    faker.number.int({min: undefined, max: undefined}),
                    null,
                ]),
                null,
            ]),
        },
        genres: Array.from(
            {length: faker.number.int({min: 1, max: 10})},
            (_, i) => i + 1,
        ).map(() => ({
            id: faker.number.int({min: undefined, max: undefined}),
            name: faker.string.alpha({length: {min: 10, max: 20}}),
        })),
        devices: Array.from(
            {length: faker.number.int({min: 1, max: 10})},
            (_, i) => i + 1,
        ).map(() => ({
            id: faker.number.int({min: undefined, max: undefined}),
            name: faker.string.alpha({length: {min: 10, max: 20}}),
            icon: faker.helpers.arrayElement([
                faker.helpers.arrayElement([
                    faker.string.alpha({length: {min: 10, max: 20}}),
                    null,
                ]),
                undefined,
            ]),
            color: faker.helpers.arrayElement([
                faker.helpers.arrayElement([
                    faker.string.alpha({length: {min: 10, max: 20}}),
                    null,
                ]),
                undefined,
            ]),
            syncAction: faker.helpers.arrayElement([
                faker.helpers.arrayElement([
                    faker.string.alpha({length: {min: 10, max: 20}}),
                    null,
                ]),
                undefined,
            ]),
        })),
        year: faker.helpers.arrayElement([
            faker.helpers.arrayElement([
                faker.number.int({min: undefined, max: undefined}),
                null,
            ]),
            null,
        ]),
        duration: faker.string.alpha({length: {min: 10, max: 20}}),
        isFavorite: faker.datatype.boolean(),
        isExplicit: faker.datatype.boolean(),
        createdAt: faker.date.past().toISOString().slice(0, 19) + "Z",
        addedAt: faker.helpers.arrayElement([
            faker.helpers.arrayElement([
                faker.date.past().toISOString().slice(0, 19) + "Z",
                null,
            ]),
            undefined,
        ]),
        lyrics: faker.helpers.arrayElement([
            faker.helpers.arrayElement([
                faker.string.alpha({length: {min: 10, max: 20}}),
                null,
            ]),
            undefined,
        ]),
    },
    ...overrideResponse,
});

export const getToggleSongFavoriteResponseMock = (
    overrideResponse: Partial<ToggleFavoriteResponse> = {},
): ToggleFavoriteResponse => ({
    isFavorite: faker.datatype.boolean(),
    ...overrideResponse,
});

export const getToggleFavoritesResponseMock = (
    overrideResponse: Partial<ToggleFavoritesResponse> = {},
): ToggleFavoritesResponse => ({
    songs: Array.from(
        {length: faker.number.int({min: 1, max: 10})},
        (_, i) => i + 1,
    ).map(() => ({
        id: faker.number.int({min: undefined, max: undefined}),
        isFavorite: faker.datatype.boolean(),
    })),
    ...overrideResponse,
});

export const getGetSongDevicesResponseMock = (
    overrideResponse: Partial<GetSongDevicesResponse> = {},
): GetSongDevicesResponse => ({
    devices: Array.from(
        {length: faker.number.int({min: 1, max: 10})},
        (_, i) => i + 1,
    ).map(() => ({
        deviceId: faker.number.int({min: undefined, max: undefined}),
        deviceName: faker.string.alpha({length: {min: 10, max: 20}}),
        deviceIcon: faker.helpers.arrayElement([
            faker.helpers.arrayElement([
                faker.string.alpha({length: {min: 10, max: 20}}),
                null,
            ]),
            undefined,
        ]),
        deviceColor: faker.helpers.arrayElement([
            faker.helpers.arrayElement([
                faker.string.alpha({length: {min: 10, max: 20}}),
                null,
            ]),
            undefined,
        ]),
        path: faker.helpers.arrayElement([
            faker.helpers.arrayElement([
                faker.string.alpha({length: {min: 10, max: 20}}),
                null,
            ]),
            undefined,
        ]),
        syncAction: faker.helpers.arrayElement([
            faker.helpers.arrayElement([
                faker.string.alpha({length: {min: 10, max: 20}}),
                null,
            ]),
            undefined,
        ]),
    })),
    ...overrideResponse,
});

export const getUpdateSongDevicesResponseMock = (
    overrideResponse: Partial<UpdateSongDevicesResponse> = {},
): UpdateSongDevicesResponse => ({
    success: faker.datatype.boolean(),
    ...overrideResponse,
});

export const getGetSongFilterMetadataResponseMock = (
    overrideResponse: Partial<FilterMetadataResponse> = {},
): FilterMetadataResponse => ({
    fields: Array.from(
        {length: faker.number.int({min: 1, max: 10})},
        (_, i) => i + 1,
    ).map(() => ({
        name: faker.string.alpha({length: {min: 10, max: 20}}),
        type: faker.string.alpha({length: {min: 10, max: 20}}),
        description: faker.string.alpha({length: {min: 10, max: 20}}),
        supportedOperators: Array.from(
            {length: faker.number.int({min: 1, max: 10})},
            (_, i) => i + 1,
        ).map(() => faker.string.alpha({length: {min: 10, max: 20}})),
        isComputed: faker.helpers.arrayElement([
            faker.datatype.boolean(),
            undefined,
        ]),
        isCollection: faker.helpers.arrayElement([
            faker.datatype.boolean(),
            undefined,
        ]),
        nestedFields: faker.helpers.arrayElement([
            Array.from(
                {length: faker.number.int({min: 1, max: 10})},
                (_, i) => i + 1,
            ).map(() => ({})),
            undefined,
        ]),
        values: faker.helpers.arrayElement([
            Array.from(
                {length: faker.number.int({min: 1, max: 10})},
                (_, i) => i + 1,
            ).map(() => faker.string.alpha({length: {min: 10, max: 20}})),
            undefined,
        ]),
        supportsDynamicValues: faker.helpers.arrayElement([
            faker.datatype.boolean(),
            undefined,
        ]),
    })),
    operators: Array.from(
        {length: faker.number.int({min: 1, max: 10})},
        (_, i) => i + 1,
    ).map(() => ({
        name: faker.string.alpha({length: {min: 10, max: 20}}),
        displayName: faker.string.alpha({length: {min: 10, max: 20}}),
        description: faker.string.alpha({length: {min: 10, max: 20}}),
        applicableTypes: Array.from(
            {length: faker.number.int({min: 1, max: 10})},
            (_, i) => i + 1,
        ).map(() => faker.string.alpha({length: {min: 10, max: 20}})),
    })),
    ...overrideResponse,
});

export const getGetSongFilterValuesResponseMock = (
    overrideResponse: Partial<FilterValuesResponse> = {},
): FilterValuesResponse => ({
    values: Array.from(
        {length: faker.number.int({min: 1, max: 10})},
        (_, i) => i + 1,
    ).map(() => faker.string.alpha({length: {min: 10, max: 20}})),
    ...overrideResponse,
});

export const getListSongsMockHandler = (
    overrideResponse?:
        | ListSongsResponse
        | ((
        info: Parameters<Parameters<typeof http.get>[1]>[0],
    ) => Promise<ListSongsResponse> | ListSongsResponse),
    options?: RequestHandlerOptions,
) => {
    return http.get(
        "*/songs",
        async (info) => {
            return new HttpResponse(
                overrideResponse !== undefined
                    ? typeof overrideResponse === "function"
                        ? await overrideResponse(info)
                        : overrideResponse
                    : getListSongsResponseMock(),
                {status: 200, headers: {"Content-Type": "text/plain"}},
            );
        },
        options,
    );
};

export const getGetSongMockHandler = (
    overrideResponse?:
        | GetSongResponse
        | ((
        info: Parameters<Parameters<typeof http.get>[1]>[0],
    ) => Promise<GetSongResponse> | GetSongResponse),
    options?: RequestHandlerOptions,
) => {
    return http.get(
        "*/songs/:id",
        async (info) => {
            return new HttpResponse(
                overrideResponse !== undefined
                    ? typeof overrideResponse === "function"
                        ? await overrideResponse(info)
                        : overrideResponse
                    : getGetSongResponseMock(),
                {status: 200, headers: {"Content-Type": "text/plain"}},
            );
        },
        options,
    );
};

export const getDownloadSongMockHandler = (
    overrideResponse?:
        | void
        | ((
        info: Parameters<Parameters<typeof http.get>[1]>[0],
    ) => Promise<void> | void),
    options?: RequestHandlerOptions,
) => {
    return http.get(
        "*/songs/:id/download",
        async (info) => {
            if (typeof overrideResponse === "function") {
                await overrideResponse(info);
            }
            return new HttpResponse(null, {status: 200});
        },
        options,
    );
};

export const getImportSongsMockHandler = (
    overrideResponse?:
        | void
        | ((
        info: Parameters<Parameters<typeof http.post>[1]>[0],
    ) => Promise<void> | void),
    options?: RequestHandlerOptions,
) => {
    return http.post(
        "*/songs/import",
        async (info) => {
            if (typeof overrideResponse === "function") {
                await overrideResponse(info);
            }
            return new HttpResponse(null, {status: 200});
        },
        options,
    );
};

export const getToggleSongFavoriteMockHandler = (
    overrideResponse?:
        | ToggleFavoriteResponse
        | ((
        info: Parameters<Parameters<typeof http.post>[1]>[0],
    ) => Promise<ToggleFavoriteResponse> | ToggleFavoriteResponse),
    options?: RequestHandlerOptions,
) => {
    return http.post(
        "*/songs/:id/favorite",
        async (info) => {
            return new HttpResponse(
                overrideResponse !== undefined
                    ? typeof overrideResponse === "function"
                        ? await overrideResponse(info)
                        : overrideResponse
                    : getToggleSongFavoriteResponseMock(),
                {status: 200, headers: {"Content-Type": "text/plain"}},
            );
        },
        options,
    );
};

export const getToggleFavoritesMockHandler = (
    overrideResponse?:
        | ToggleFavoritesResponse
        | ((
        info: Parameters<Parameters<typeof http.post>[1]>[0],
    ) => Promise<ToggleFavoritesResponse> | ToggleFavoritesResponse),
    options?: RequestHandlerOptions,
) => {
    return http.post(
        "*/songs/favorites",
        async (info) => {
            return new HttpResponse(
                overrideResponse !== undefined
                    ? typeof overrideResponse === "function"
                        ? await overrideResponse(info)
                        : overrideResponse
                    : getToggleFavoritesResponseMock(),
                {status: 200, headers: {"Content-Type": "text/plain"}},
            );
        },
        options,
    );
};

export const getGetSongDevicesMockHandler = (
    overrideResponse?:
        | GetSongDevicesResponse
        | ((
        info: Parameters<Parameters<typeof http.get>[1]>[0],
    ) => Promise<GetSongDevicesResponse> | GetSongDevicesResponse),
    options?: RequestHandlerOptions,
) => {
    return http.get(
        "*/songs/:id/devices",
        async (info) => {
            return new HttpResponse(
                overrideResponse !== undefined
                    ? typeof overrideResponse === "function"
                        ? await overrideResponse(info)
                        : overrideResponse
                    : getGetSongDevicesResponseMock(),
                {status: 200, headers: {"Content-Type": "text/plain"}},
            );
        },
        options,
    );
};

export const getUpdateSongDevicesMockHandler = (
    overrideResponse?:
        | UpdateSongDevicesResponse
        | ((
        info: Parameters<Parameters<typeof http.put>[1]>[0],
    ) => Promise<UpdateSongDevicesResponse> | UpdateSongDevicesResponse),
    options?: RequestHandlerOptions,
) => {
    return http.put(
        "*/songs/devices",
        async (info) => {
            return new HttpResponse(
                overrideResponse !== undefined
                    ? typeof overrideResponse === "function"
                        ? await overrideResponse(info)
                        : overrideResponse
                    : getUpdateSongDevicesResponseMock(),
                {status: 200, headers: {"Content-Type": "text/plain"}},
            );
        },
        options,
    );
};

export const getGetSongFilterMetadataMockHandler = (
    overrideResponse?:
        | FilterMetadataResponse
        | ((
        info: Parameters<Parameters<typeof http.get>[1]>[0],
    ) => Promise<FilterMetadataResponse> | FilterMetadataResponse),
    options?: RequestHandlerOptions,
) => {
    return http.get(
        "*/songs/filter-metadata",
        async (info) => {
            return new HttpResponse(
                overrideResponse !== undefined
                    ? typeof overrideResponse === "function"
                        ? await overrideResponse(info)
                        : overrideResponse
                    : getGetSongFilterMetadataResponseMock(),
                {status: 200, headers: {"Content-Type": "text/plain"}},
            );
        },
        options,
    );
};

export const getGetSongFilterValuesMockHandler = (
    overrideResponse?:
        | FilterValuesResponse
        | ((
        info: Parameters<Parameters<typeof http.get>[1]>[0],
    ) => Promise<FilterValuesResponse> | FilterValuesResponse),
    options?: RequestHandlerOptions,
) => {
    return http.get(
        "*/songs/filter-values",
        async (info) => {
            return new HttpResponse(
                overrideResponse !== undefined
                    ? typeof overrideResponse === "function"
                        ? await overrideResponse(info)
                        : overrideResponse
                    : getGetSongFilterValuesResponseMock(),
                {status: 200, headers: {"Content-Type": "text/plain"}},
            );
        },
        options,
    );
};
export const getSongsMock = () => [
    getListSongsMockHandler(),
    getGetSongMockHandler(),
    getDownloadSongMockHandler(),
    getImportSongsMockHandler(),
    getToggleSongFavoriteMockHandler(),
    getToggleFavoritesMockHandler(),
    getGetSongDevicesMockHandler(),
    getUpdateSongDevicesMockHandler(),
    getGetSongFilterMetadataMockHandler(),
    getGetSongFilterValuesMockHandler(),
];
