/**
 * Generated by orval v8.2.0 ðŸº
 * Do not edit manually.
 * MyMusic.Server | v1
 * OpenAPI spec version: 1.0.0
 */

import {faker} from "@faker-js/faker";
import type {
    DataTag,
    DefinedInitialDataOptions,
    DefinedUseQueryResult,
    InvalidateOptions,
    MutationFunction,
    QueryClient,
    QueryFunction,
    QueryKey,
    UndefinedInitialDataOptions,
    UseMutationOptions,
    UseMutationResult,
    UseQueryOptions,
    UseQueryResult,
} from "@tanstack/react-query";
import {useMutation, useQuery} from "@tanstack/react-query";
import type {RequestHandlerOptions} from "msw";

import {HttpResponse, http} from "msw";
import type {
    CreateSourceRequest,
    CreateSourceResponse,
    DeleteSourceResponse,
    GetSourceResponse,
    ListSourcesResponse,
    SourceAlbum,
    SourceSong,
    Stream,
    UpdateSourceRequest,
    UpdateSourceResponse,
} from "../model";

export type listSourcesResponse200 = {
    data: ListSourcesResponse;
    status: 200;
};

export type listSourcesResponseSuccess = listSourcesResponse200 & {
    headers: Headers;
};

export type listSourcesResponse = listSourcesResponseSuccess;

export const getListSourcesUrl = () => {
    return `/api/sources`;
};

export const listSources = async (
    options?: RequestInit,
): Promise<listSourcesResponse> => {
    const res = await fetch(getListSourcesUrl(), {
        ...options,
        method: "GET",
    });

    const body = [204, 205, 304].includes(res.status) ? null : await res.text();

    const data: listSourcesResponse["data"] = body ? JSON.parse(body) : {};
    return {
        data,
        status: res.status,
        headers: res.headers,
    } as listSourcesResponse;
};

export const getListSourcesQueryKey = () => {
    return ["api", "sources"] as const;
};

export const getListSourcesQueryOptions = <
    TData = Awaited<ReturnType<typeof listSources>>,
    TError = unknown,
>(options?: {
    query?: Partial<
        UseQueryOptions<Awaited<ReturnType<typeof listSources>>, TError, TData>
    >;
    fetch?: RequestInit;
}) => {
    const {query: queryOptions, fetch: fetchOptions} = options ?? {};

    const queryKey = queryOptions?.queryKey ?? getListSourcesQueryKey();

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listSources>>> = ({
                                                                                 signal,
                                                                             }) => listSources({signal, ...fetchOptions});

    return {queryKey, queryFn, ...queryOptions} as UseQueryOptions<
        Awaited<ReturnType<typeof listSources>>,
        TError,
        TData
    > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ListSourcesQueryResult = NonNullable<
    Awaited<ReturnType<typeof listSources>>
>;
export type ListSourcesQueryError = unknown;

export function useListSources<
    TData = Awaited<ReturnType<typeof listSources>>,
    TError = unknown,
>(
    options: {
        query: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof listSources>>, TError, TData>
        > &
            Pick<
                DefinedInitialDataOptions<
                    Awaited<ReturnType<typeof listSources>>,
                    TError,
                    Awaited<ReturnType<typeof listSources>>
                >,
                "initialData"
            >;
        fetch?: RequestInit;
    },
    queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useListSources<
    TData = Awaited<ReturnType<typeof listSources>>,
    TError = unknown,
>(
    options?: {
        query?: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof listSources>>, TError, TData>
        > &
            Pick<
                UndefinedInitialDataOptions<
                    Awaited<ReturnType<typeof listSources>>,
                    TError,
                    Awaited<ReturnType<typeof listSources>>
                >,
                "initialData"
            >;
        fetch?: RequestInit;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useListSources<
    TData = Awaited<ReturnType<typeof listSources>>,
    TError = unknown,
>(
    options?: {
        query?: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof listSources>>, TError, TData>
        >;
        fetch?: RequestInit;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};

export function useListSources<
    TData = Awaited<ReturnType<typeof listSources>>,
    TError = unknown,
>(
    options?: {
        query?: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof listSources>>, TError, TData>
        >;
        fetch?: RequestInit;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
} {
    const queryOptions = getListSourcesQueryOptions(options);

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<
        TData,
        TError
    > & { queryKey: DataTag<QueryKey, TData, TError> };

    return {...query, queryKey: queryOptions.queryKey};
}

export const invalidateListSources = async (
    queryClient: QueryClient,
    options?: InvalidateOptions,
): Promise<QueryClient> => {
    await queryClient.invalidateQueries(
        {queryKey: getListSourcesQueryKey()},
        options,
    );

    return queryClient;
};

export type createSourceResponse200 = {
    data: CreateSourceResponse;
    status: 200;
};

export type createSourceResponseSuccess = createSourceResponse200 & {
    headers: Headers;
};

export type createSourceResponse = createSourceResponseSuccess;

export const getCreateSourceUrl = () => {
    return `/api/sources`;
};

export const createSource = async (
    createSourceRequest: CreateSourceRequest,
    options?: RequestInit,
): Promise<createSourceResponse> => {
    const res = await fetch(getCreateSourceUrl(), {
        ...options,
        method: "POST",
        headers: {"Content-Type": "application/json", ...options?.headers},
        body: JSON.stringify(createSourceRequest),
    });

    const body = [204, 205, 304].includes(res.status) ? null : await res.text();

    const data: createSourceResponse["data"] = body ? JSON.parse(body) : {};
    return {
        data,
        status: res.status,
        headers: res.headers,
    } as createSourceResponse;
};

export const getCreateSourceMutationOptions = <
    TError = unknown,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof createSource>>,
        TError,
        { data: CreateSourceRequest },
        TContext
    >;
    fetch?: RequestInit;
}): UseMutationOptions<
    Awaited<ReturnType<typeof createSource>>,
    TError,
    { data: CreateSourceRequest },
    TContext
> => {
    const mutationKey = ["createSource"];
    const {mutation: mutationOptions, fetch: fetchOptions} = options
        ? options.mutation &&
        "mutationKey" in options.mutation &&
        options.mutation.mutationKey
            ? options
            : {...options, mutation: {...options.mutation, mutationKey}}
        : {mutation: {mutationKey}, fetch: undefined};

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof createSource>>,
        { data: CreateSourceRequest }
    > = (props) => {
        const {data} = props ?? {};

        return createSource(data, fetchOptions);
    };

    return {mutationFn, ...mutationOptions};
};

export type CreateSourceMutationResult = NonNullable<
    Awaited<ReturnType<typeof createSource>>
>;
export type CreateSourceMutationBody = CreateSourceRequest;
export type CreateSourceMutationError = unknown;

export const useCreateSource = <TError = unknown, TContext = unknown>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof createSource>>,
            TError,
            { data: CreateSourceRequest },
            TContext
        >;
        fetch?: RequestInit;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof createSource>>,
    TError,
    { data: CreateSourceRequest },
    TContext
> => {
    return useMutation(getCreateSourceMutationOptions(options), queryClient);
};
export type getSourceResponse200 = {
    data: GetSourceResponse;
    status: 200;
};

export type getSourceResponseSuccess = getSourceResponse200 & {
    headers: Headers;
};

export type getSourceResponse = getSourceResponseSuccess;

export const getGetSourceUrl = (id: number) => {
    return `/api/sources/${id}`;
};

export const getSource = async (
    id: number,
    options?: RequestInit,
): Promise<getSourceResponse> => {
    const res = await fetch(getGetSourceUrl(id), {
        ...options,
        method: "GET",
    });

    const body = [204, 205, 304].includes(res.status) ? null : await res.text();

    const data: getSourceResponse["data"] = body ? JSON.parse(body) : {};
    return {
        data,
        status: res.status,
        headers: res.headers,
    } as getSourceResponse;
};

export const getGetSourceQueryKey = (id: number) => {
    return ["api", "sources", id] as const;
};

export const getGetSourceQueryOptions = <
    TData = Awaited<ReturnType<typeof getSource>>,
    TError = unknown,
>(
    id: number,
    options?: {
        query?: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof getSource>>, TError, TData>
        >;
        fetch?: RequestInit;
    },
) => {
    const {query: queryOptions, fetch: fetchOptions} = options ?? {};

    const queryKey = queryOptions?.queryKey ?? getGetSourceQueryKey(id);

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSource>>> = ({
                                                                               signal,
                                                                           }) => getSource(id, {signal, ...fetchOptions});

    return {
        queryKey,
        queryFn,
        enabled: !!id,
        ...queryOptions,
    } as UseQueryOptions<Awaited<ReturnType<typeof getSource>>, TError, TData> & {
        queryKey: DataTag<QueryKey, TData, TError>;
    };
};

export type GetSourceQueryResult = NonNullable<
    Awaited<ReturnType<typeof getSource>>
>;
export type GetSourceQueryError = unknown;

export function useGetSource<
    TData = Awaited<ReturnType<typeof getSource>>,
    TError = unknown,
>(
    id: number,
    options: {
        query: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof getSource>>, TError, TData>
        > &
            Pick<
                DefinedInitialDataOptions<
                    Awaited<ReturnType<typeof getSource>>,
                    TError,
                    Awaited<ReturnType<typeof getSource>>
                >,
                "initialData"
            >;
        fetch?: RequestInit;
    },
    queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSource<
    TData = Awaited<ReturnType<typeof getSource>>,
    TError = unknown,
>(
    id: number,
    options?: {
        query?: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof getSource>>, TError, TData>
        > &
            Pick<
                UndefinedInitialDataOptions<
                    Awaited<ReturnType<typeof getSource>>,
                    TError,
                    Awaited<ReturnType<typeof getSource>>
                >,
                "initialData"
            >;
        fetch?: RequestInit;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSource<
    TData = Awaited<ReturnType<typeof getSource>>,
    TError = unknown,
>(
    id: number,
    options?: {
        query?: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof getSource>>, TError, TData>
        >;
        fetch?: RequestInit;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetSource<
    TData = Awaited<ReturnType<typeof getSource>>,
    TError = unknown,
>(
    id: number,
    options?: {
        query?: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof getSource>>, TError, TData>
        >;
        fetch?: RequestInit;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
} {
    const queryOptions = getGetSourceQueryOptions(id, options);

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<
        TData,
        TError
    > & { queryKey: DataTag<QueryKey, TData, TError> };

    return {...query, queryKey: queryOptions.queryKey};
}

export const invalidateGetSource = async (
    queryClient: QueryClient,
    id: number,
    options?: InvalidateOptions,
): Promise<QueryClient> => {
    await queryClient.invalidateQueries(
        {queryKey: getGetSourceQueryKey(id)},
        options,
    );

    return queryClient;
};

export type updateSourceResponse200 = {
    data: UpdateSourceResponse;
    status: 200;
};

export type updateSourceResponseSuccess = updateSourceResponse200 & {
    headers: Headers;
};

export type updateSourceResponse = updateSourceResponseSuccess;

export const getUpdateSourceUrl = (id: number) => {
    return `/api/sources/${id}`;
};

export const updateSource = async (
    id: number,
    updateSourceRequest: UpdateSourceRequest,
    options?: RequestInit,
): Promise<updateSourceResponse> => {
    const res = await fetch(getUpdateSourceUrl(id), {
        ...options,
        method: "PUT",
        headers: {"Content-Type": "application/json", ...options?.headers},
        body: JSON.stringify(updateSourceRequest),
    });

    const body = [204, 205, 304].includes(res.status) ? null : await res.text();

    const data: updateSourceResponse["data"] = body ? JSON.parse(body) : {};
    return {
        data,
        status: res.status,
        headers: res.headers,
    } as updateSourceResponse;
};

export const getUpdateSourceMutationOptions = <
    TError = unknown,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof updateSource>>,
        TError,
        { id: number; data: UpdateSourceRequest },
        TContext
    >;
    fetch?: RequestInit;
}): UseMutationOptions<
    Awaited<ReturnType<typeof updateSource>>,
    TError,
    { id: number; data: UpdateSourceRequest },
    TContext
> => {
    const mutationKey = ["updateSource"];
    const {mutation: mutationOptions, fetch: fetchOptions} = options
        ? options.mutation &&
        "mutationKey" in options.mutation &&
        options.mutation.mutationKey
            ? options
            : {...options, mutation: {...options.mutation, mutationKey}}
        : {mutation: {mutationKey}, fetch: undefined};

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof updateSource>>,
        { id: number; data: UpdateSourceRequest }
    > = (props) => {
        const {id, data} = props ?? {};

        return updateSource(id, data, fetchOptions);
    };

    return {mutationFn, ...mutationOptions};
};

export type UpdateSourceMutationResult = NonNullable<
    Awaited<ReturnType<typeof updateSource>>
>;
export type UpdateSourceMutationBody = UpdateSourceRequest;
export type UpdateSourceMutationError = unknown;

export const useUpdateSource = <TError = unknown, TContext = unknown>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof updateSource>>,
            TError,
            { id: number; data: UpdateSourceRequest },
            TContext
        >;
        fetch?: RequestInit;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof updateSource>>,
    TError,
    { id: number; data: UpdateSourceRequest },
    TContext
> => {
    return useMutation(getUpdateSourceMutationOptions(options), queryClient);
};
export type deleteSourceResponse200 = {
    data: DeleteSourceResponse;
    status: 200;
};

export type deleteSourceResponseSuccess = deleteSourceResponse200 & {
    headers: Headers;
};

export type deleteSourceResponse = deleteSourceResponseSuccess;

export const getDeleteSourceUrl = (id: number) => {
    return `/api/sources/${id}`;
};

export const deleteSource = async (
    id: number,
    options?: RequestInit,
): Promise<deleteSourceResponse> => {
    const res = await fetch(getDeleteSourceUrl(id), {
        ...options,
        method: "DELETE",
    });

    const body = [204, 205, 304].includes(res.status) ? null : await res.text();

    const data: deleteSourceResponse["data"] = body ? JSON.parse(body) : {};
    return {
        data,
        status: res.status,
        headers: res.headers,
    } as deleteSourceResponse;
};

export const getDeleteSourceMutationOptions = <
    TError = unknown,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof deleteSource>>,
        TError,
        { id: number },
        TContext
    >;
    fetch?: RequestInit;
}): UseMutationOptions<
    Awaited<ReturnType<typeof deleteSource>>,
    TError,
    { id: number },
    TContext
> => {
    const mutationKey = ["deleteSource"];
    const {mutation: mutationOptions, fetch: fetchOptions} = options
        ? options.mutation &&
        "mutationKey" in options.mutation &&
        options.mutation.mutationKey
            ? options
            : {...options, mutation: {...options.mutation, mutationKey}}
        : {mutation: {mutationKey}, fetch: undefined};

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof deleteSource>>,
        { id: number }
    > = (props) => {
        const {id} = props ?? {};

        return deleteSource(id, fetchOptions);
    };

    return {mutationFn, ...mutationOptions};
};

export type DeleteSourceMutationResult = NonNullable<
    Awaited<ReturnType<typeof deleteSource>>
>;

export type DeleteSourceMutationError = unknown;

export const useDeleteSource = <TError = unknown, TContext = unknown>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof deleteSource>>,
            TError,
            { id: number },
            TContext
        >;
        fetch?: RequestInit;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof deleteSource>>,
    TError,
    { id: number },
    TContext
> => {
    return useMutation(getDeleteSourceMutationOptions(options), queryClient);
};
export type searchSongsResponse200 = {
    data: SourceSong[];
    status: 200;
};

export type searchSongsResponseSuccess = searchSongsResponse200 & {
    headers: Headers;
};

export type searchSongsResponse = searchSongsResponseSuccess;

export const getSearchSongsUrl = (id: number, query: string) => {
    return `/api/sources/${id}/songs/search/${query}`;
};

export const searchSongs = async (
    id: number,
    query: string,
    options?: RequestInit,
): Promise<searchSongsResponse> => {
    const res = await fetch(getSearchSongsUrl(id, query), {
        ...options,
        method: "GET",
    });

    const body = [204, 205, 304].includes(res.status) ? null : await res.text();

    const data: searchSongsResponse["data"] = body ? JSON.parse(body) : {};
    return {
        data,
        status: res.status,
        headers: res.headers,
    } as searchSongsResponse;
};

export const getSearchSongsQueryKey = (id: number, query: string) => {
    return ["api", "sources", id, "songs", "search", query] as const;
};

export const getSearchSongsQueryOptions = <
    TData = Awaited<ReturnType<typeof searchSongs>>,
    TError = unknown,
>(
    id: number,
    query: string,
    options?: {
        query?: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof searchSongs>>, TError, TData>
        >;
        fetch?: RequestInit;
    },
) => {
    const {query: queryOptions, fetch: fetchOptions} = options ?? {};

    const queryKey = queryOptions?.queryKey ?? getSearchSongsQueryKey(id, query);

    const queryFn: QueryFunction<Awaited<ReturnType<typeof searchSongs>>> = ({
                                                                                 signal,
                                                                             }) => searchSongs(id, query, {signal, ...fetchOptions});

    return {
        queryKey,
        queryFn,
        enabled: !!(id && query),
        ...queryOptions,
    } as UseQueryOptions<
        Awaited<ReturnType<typeof searchSongs>>,
        TError,
        TData
    > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type SearchSongsQueryResult = NonNullable<
    Awaited<ReturnType<typeof searchSongs>>
>;
export type SearchSongsQueryError = unknown;

export function useSearchSongs<
    TData = Awaited<ReturnType<typeof searchSongs>>,
    TError = unknown,
>(
    id: number,
    query: string,
    options: {
        query: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof searchSongs>>, TError, TData>
        > &
            Pick<
                DefinedInitialDataOptions<
                    Awaited<ReturnType<typeof searchSongs>>,
                    TError,
                    Awaited<ReturnType<typeof searchSongs>>
                >,
                "initialData"
            >;
        fetch?: RequestInit;
    },
    queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useSearchSongs<
    TData = Awaited<ReturnType<typeof searchSongs>>,
    TError = unknown,
>(
    id: number,
    query: string,
    options?: {
        query?: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof searchSongs>>, TError, TData>
        > &
            Pick<
                UndefinedInitialDataOptions<
                    Awaited<ReturnType<typeof searchSongs>>,
                    TError,
                    Awaited<ReturnType<typeof searchSongs>>
                >,
                "initialData"
            >;
        fetch?: RequestInit;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useSearchSongs<
    TData = Awaited<ReturnType<typeof searchSongs>>,
    TError = unknown,
>(
    id: number,
    query: string,
    options?: {
        query?: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof searchSongs>>, TError, TData>
        >;
        fetch?: RequestInit;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};

export function useSearchSongs<
    TData = Awaited<ReturnType<typeof searchSongs>>,
    TError = unknown,
>(
    id: number,
    query: string,
    options?: {
        query?: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof searchSongs>>, TError, TData>
        >;
        fetch?: RequestInit;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
} {
    const queryOptions = getSearchSongsQueryOptions(id, query, options);

    const _query = useQuery(queryOptions, queryClient) as UseQueryResult<
        TData,
        TError
    > & { queryKey: DataTag<QueryKey, TData, TError> };

    return {..._query, queryKey: queryOptions.queryKey};
}

export const invalidateSearchSongs = async (
    queryClient: QueryClient,
    id: number,
    query: string,
    options?: InvalidateOptions,
): Promise<QueryClient> => {
    await queryClient.invalidateQueries(
        {queryKey: getSearchSongsQueryKey(id, query)},
        options,
    );

    return queryClient;
};

export type getSongResponse200 = {
    data: SourceSong;
    status: 200;
};

export type getSongResponseSuccess = getSongResponse200 & {
    headers: Headers;
};

export type getSongResponse = getSongResponseSuccess;

export const getGetSongUrl = (id: number, songId: string) => {
    return `/api/sources/${id}/songs/${songId}`;
};

export const getSong = async (
    id: number,
    songId: string,
    options?: RequestInit,
): Promise<getSongResponse> => {
    const res = await fetch(getGetSongUrl(id, songId), {
        ...options,
        method: "GET",
    });

    const body = [204, 205, 304].includes(res.status) ? null : await res.text();

    const data: getSongResponse["data"] = body ? JSON.parse(body) : {};
    return {data, status: res.status, headers: res.headers} as getSongResponse;
};

export const getGetSongQueryKey = (id: number, songId: string) => {
    return ["api", "sources", id, "songs", songId] as const;
};

export const getGetSongQueryOptions = <
    TData = Awaited<ReturnType<typeof getSong>>,
    TError = unknown,
>(
    id: number,
    songId: string,
    options?: {
        query?: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof getSong>>, TError, TData>
        >;
        fetch?: RequestInit;
    },
) => {
    const {query: queryOptions, fetch: fetchOptions} = options ?? {};

    const queryKey = queryOptions?.queryKey ?? getGetSongQueryKey(id, songId);

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSong>>> = ({
                                                                             signal,
                                                                         }) => getSong(id, songId, {signal, ...fetchOptions});

    return {
        queryKey,
        queryFn,
        enabled: !!(id && songId),
        ...queryOptions,
    } as UseQueryOptions<Awaited<ReturnType<typeof getSong>>, TError, TData> & {
        queryKey: DataTag<QueryKey, TData, TError>;
    };
};

export type GetSongQueryResult = NonNullable<
    Awaited<ReturnType<typeof getSong>>
>;
export type GetSongQueryError = unknown;

export function useGetSong<
    TData = Awaited<ReturnType<typeof getSong>>,
    TError = unknown,
>(
    id: number,
    songId: string,
    options: {
        query: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof getSong>>, TError, TData>
        > &
            Pick<
                DefinedInitialDataOptions<
                    Awaited<ReturnType<typeof getSong>>,
                    TError,
                    Awaited<ReturnType<typeof getSong>>
                >,
                "initialData"
            >;
        fetch?: RequestInit;
    },
    queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSong<
    TData = Awaited<ReturnType<typeof getSong>>,
    TError = unknown,
>(
    id: number,
    songId: string,
    options?: {
        query?: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof getSong>>, TError, TData>
        > &
            Pick<
                UndefinedInitialDataOptions<
                    Awaited<ReturnType<typeof getSong>>,
                    TError,
                    Awaited<ReturnType<typeof getSong>>
                >,
                "initialData"
            >;
        fetch?: RequestInit;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSong<
    TData = Awaited<ReturnType<typeof getSong>>,
    TError = unknown,
>(
    id: number,
    songId: string,
    options?: {
        query?: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof getSong>>, TError, TData>
        >;
        fetch?: RequestInit;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetSong<
    TData = Awaited<ReturnType<typeof getSong>>,
    TError = unknown,
>(
    id: number,
    songId: string,
    options?: {
        query?: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof getSong>>, TError, TData>
        >;
        fetch?: RequestInit;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
} {
    const queryOptions = getGetSongQueryOptions(id, songId, options);

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<
        TData,
        TError
    > & { queryKey: DataTag<QueryKey, TData, TError> };

    return {...query, queryKey: queryOptions.queryKey};
}

export const invalidateGetSong = async (
    queryClient: QueryClient,
    id: number,
    songId: string,
    options?: InvalidateOptions,
): Promise<QueryClient> => {
    await queryClient.invalidateQueries(
        {queryKey: getGetSongQueryKey(id, songId)},
        options,
    );

    return queryClient;
};

export type purchaseSongResponse200 = {
    data: Stream;
    status: 200;
};

export type purchaseSongResponseSuccess = purchaseSongResponse200 & {
    headers: Headers;
};

export type purchaseSongResponse = purchaseSongResponseSuccess;

export const getPurchaseSongUrl = (id: number, songId: string) => {
    return `/api/sources/${id}/songs/purchase/${songId}`;
};

export const purchaseSong = async (
    id: number,
    songId: string,
    options?: RequestInit,
): Promise<purchaseSongResponse> => {
    const res = await fetch(getPurchaseSongUrl(id, songId), {
        ...options,
        method: "GET",
    });

    const body = [204, 205, 304].includes(res.status) ? null : await res.text();

    const data: purchaseSongResponse["data"] = body ? JSON.parse(body) : {};
    return {
        data,
        status: res.status,
        headers: res.headers,
    } as purchaseSongResponse;
};

export const getPurchaseSongQueryKey = (id: number, songId: string) => {
    return ["api", "sources", id, "songs", "purchase", songId] as const;
};

export const getPurchaseSongQueryOptions = <
    TData = Awaited<ReturnType<typeof purchaseSong>>,
    TError = unknown,
>(
    id: number,
    songId: string,
    options?: {
        query?: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof purchaseSong>>, TError, TData>
        >;
        fetch?: RequestInit;
    },
) => {
    const {query: queryOptions, fetch: fetchOptions} = options ?? {};

    const queryKey =
        queryOptions?.queryKey ?? getPurchaseSongQueryKey(id, songId);

    const queryFn: QueryFunction<Awaited<ReturnType<typeof purchaseSong>>> = ({
                                                                                  signal,
                                                                              }) => purchaseSong(id, songId, {signal, ...fetchOptions});

    return {
        queryKey,
        queryFn,
        enabled: !!(id && songId),
        ...queryOptions,
    } as UseQueryOptions<
        Awaited<ReturnType<typeof purchaseSong>>,
        TError,
        TData
    > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type PurchaseSongQueryResult = NonNullable<
    Awaited<ReturnType<typeof purchaseSong>>
>;
export type PurchaseSongQueryError = unknown;

export function usePurchaseSong<
    TData = Awaited<ReturnType<typeof purchaseSong>>,
    TError = unknown,
>(
    id: number,
    songId: string,
    options: {
        query: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof purchaseSong>>, TError, TData>
        > &
            Pick<
                DefinedInitialDataOptions<
                    Awaited<ReturnType<typeof purchaseSong>>,
                    TError,
                    Awaited<ReturnType<typeof purchaseSong>>
                >,
                "initialData"
            >;
        fetch?: RequestInit;
    },
    queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePurchaseSong<
    TData = Awaited<ReturnType<typeof purchaseSong>>,
    TError = unknown,
>(
    id: number,
    songId: string,
    options?: {
        query?: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof purchaseSong>>, TError, TData>
        > &
            Pick<
                UndefinedInitialDataOptions<
                    Awaited<ReturnType<typeof purchaseSong>>,
                    TError,
                    Awaited<ReturnType<typeof purchaseSong>>
                >,
                "initialData"
            >;
        fetch?: RequestInit;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePurchaseSong<
    TData = Awaited<ReturnType<typeof purchaseSong>>,
    TError = unknown,
>(
    id: number,
    songId: string,
    options?: {
        query?: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof purchaseSong>>, TError, TData>
        >;
        fetch?: RequestInit;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};

export function usePurchaseSong<
    TData = Awaited<ReturnType<typeof purchaseSong>>,
    TError = unknown,
>(
    id: number,
    songId: string,
    options?: {
        query?: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof purchaseSong>>, TError, TData>
        >;
        fetch?: RequestInit;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
} {
    const queryOptions = getPurchaseSongQueryOptions(id, songId, options);

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<
        TData,
        TError
    > & { queryKey: DataTag<QueryKey, TData, TError> };

    return {...query, queryKey: queryOptions.queryKey};
}

export const invalidatePurchaseSong = async (
    queryClient: QueryClient,
    id: number,
    songId: string,
    options?: InvalidateOptions,
): Promise<QueryClient> => {
    await queryClient.invalidateQueries(
        {queryKey: getPurchaseSongQueryKey(id, songId)},
        options,
    );

    return queryClient;
};

export type searchAlbumsResponse200 = {
    data: SourceAlbum[];
    status: 200;
};

export type searchAlbumsResponseSuccess = searchAlbumsResponse200 & {
    headers: Headers;
};

export type searchAlbumsResponse = searchAlbumsResponseSuccess;

export const getSearchAlbumsUrl = (id: number, query: string) => {
    return `/api/sources/${id}/albums/search/${query}`;
};

export const searchAlbums = async (
    id: number,
    query: string,
    options?: RequestInit,
): Promise<searchAlbumsResponse> => {
    const res = await fetch(getSearchAlbumsUrl(id, query), {
        ...options,
        method: "GET",
    });

    const body = [204, 205, 304].includes(res.status) ? null : await res.text();

    const data: searchAlbumsResponse["data"] = body ? JSON.parse(body) : {};
    return {
        data,
        status: res.status,
        headers: res.headers,
    } as searchAlbumsResponse;
};

export const getSearchAlbumsQueryKey = (id: number, query: string) => {
    return ["api", "sources", id, "albums", "search", query] as const;
};

export const getSearchAlbumsQueryOptions = <
    TData = Awaited<ReturnType<typeof searchAlbums>>,
    TError = unknown,
>(
    id: number,
    query: string,
    options?: {
        query?: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof searchAlbums>>, TError, TData>
        >;
        fetch?: RequestInit;
    },
) => {
    const {query: queryOptions, fetch: fetchOptions} = options ?? {};

    const queryKey = queryOptions?.queryKey ?? getSearchAlbumsQueryKey(id, query);

    const queryFn: QueryFunction<Awaited<ReturnType<typeof searchAlbums>>> = ({
                                                                                  signal,
                                                                              }) => searchAlbums(id, query, {signal, ...fetchOptions});

    return {
        queryKey,
        queryFn,
        enabled: !!(id && query),
        ...queryOptions,
    } as UseQueryOptions<
        Awaited<ReturnType<typeof searchAlbums>>,
        TError,
        TData
    > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type SearchAlbumsQueryResult = NonNullable<
    Awaited<ReturnType<typeof searchAlbums>>
>;
export type SearchAlbumsQueryError = unknown;

export function useSearchAlbums<
    TData = Awaited<ReturnType<typeof searchAlbums>>,
    TError = unknown,
>(
    id: number,
    query: string,
    options: {
        query: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof searchAlbums>>, TError, TData>
        > &
            Pick<
                DefinedInitialDataOptions<
                    Awaited<ReturnType<typeof searchAlbums>>,
                    TError,
                    Awaited<ReturnType<typeof searchAlbums>>
                >,
                "initialData"
            >;
        fetch?: RequestInit;
    },
    queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useSearchAlbums<
    TData = Awaited<ReturnType<typeof searchAlbums>>,
    TError = unknown,
>(
    id: number,
    query: string,
    options?: {
        query?: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof searchAlbums>>, TError, TData>
        > &
            Pick<
                UndefinedInitialDataOptions<
                    Awaited<ReturnType<typeof searchAlbums>>,
                    TError,
                    Awaited<ReturnType<typeof searchAlbums>>
                >,
                "initialData"
            >;
        fetch?: RequestInit;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useSearchAlbums<
    TData = Awaited<ReturnType<typeof searchAlbums>>,
    TError = unknown,
>(
    id: number,
    query: string,
    options?: {
        query?: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof searchAlbums>>, TError, TData>
        >;
        fetch?: RequestInit;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};

export function useSearchAlbums<
    TData = Awaited<ReturnType<typeof searchAlbums>>,
    TError = unknown,
>(
    id: number,
    query: string,
    options?: {
        query?: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof searchAlbums>>, TError, TData>
        >;
        fetch?: RequestInit;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
} {
    const queryOptions = getSearchAlbumsQueryOptions(id, query, options);

    const _query = useQuery(queryOptions, queryClient) as UseQueryResult<
        TData,
        TError
    > & { queryKey: DataTag<QueryKey, TData, TError> };

    return {..._query, queryKey: queryOptions.queryKey};
}

export const invalidateSearchAlbums = async (
    queryClient: QueryClient,
    id: number,
    query: string,
    options?: InvalidateOptions,
): Promise<QueryClient> => {
    await queryClient.invalidateQueries(
        {queryKey: getSearchAlbumsQueryKey(id, query)},
        options,
    );

    return queryClient;
};

export const getListSourcesResponseMock = (
    overrideResponse: Partial<ListSourcesResponse> = {},
): ListSourcesResponse => ({
    sources: Array.from(
        {length: faker.number.int({min: 1, max: 10})},
        (_, i) => i + 1,
    ).map(() => ({
        id: faker.number.int({min: undefined, max: undefined}),
        icon: faker.string.alpha({length: {min: 10, max: 20}}),
        name: faker.string.alpha({length: {min: 10, max: 20}}),
        address: faker.string.alpha({length: {min: 10, max: 20}}),
        isPaid: faker.datatype.boolean(),
    })),
    ...overrideResponse,
});

export const getCreateSourceResponseMock = (
    overrideResponse: Partial<CreateSourceResponse> = {},
): CreateSourceResponse => ({
    source: {
        id: faker.number.int({min: undefined, max: undefined}),
        icon: faker.string.alpha({length: {min: 10, max: 20}}),
        name: faker.string.alpha({length: {min: 10, max: 20}}),
        address: faker.string.alpha({length: {min: 10, max: 20}}),
        isPaid: faker.datatype.boolean(),
    },
    ...overrideResponse,
});

export const getGetSourceResponseMock = (
    overrideResponse: Partial<GetSourceResponse> = {},
): GetSourceResponse => ({
    source: {
        id: faker.number.int({min: undefined, max: undefined}),
        icon: faker.string.alpha({length: {min: 10, max: 20}}),
        name: faker.string.alpha({length: {min: 10, max: 20}}),
        address: faker.string.alpha({length: {min: 10, max: 20}}),
        isPaid: faker.datatype.boolean(),
    },
    ...overrideResponse,
});

export const getUpdateSourceResponseMock = (
    overrideResponse: Partial<UpdateSourceResponse> = {},
): UpdateSourceResponse => ({
    source: {
        icon: faker.string.alpha({length: {min: 10, max: 20}}),
        name: faker.string.alpha({length: {min: 10, max: 20}}),
        address: faker.string.alpha({length: {min: 10, max: 20}}),
        isPaid: faker.datatype.boolean(),
    },
    ...overrideResponse,
});

export const getDeleteSourceResponseMock = (
    overrideResponse: Partial<DeleteSourceResponse> = {},
): DeleteSourceResponse => ({
    source: {
        id: faker.number.int({min: undefined, max: undefined}),
        icon: faker.string.alpha({length: {min: 10, max: 20}}),
        name: faker.string.alpha({length: {min: 10, max: 20}}),
        address: faker.string.alpha({length: {min: 10, max: 20}}),
        isPaid: faker.datatype.boolean(),
    },
    ...overrideResponse,
});

export const getSearchSongsResponseMock = (): SourceSong[] =>
    Array.from(
        {length: faker.number.int({min: 1, max: 10})},
        (_, i) => i + 1,
    ).map(() => ({
        id: faker.string.alpha({length: {min: 10, max: 20}}),
        title: faker.string.alpha({length: {min: 10, max: 20}}),
        album: faker.helpers.arrayElement([
            {
                id: faker.string.alpha({length: {min: 10, max: 20}}),
                name: faker.string.alpha({length: {min: 10, max: 20}}),
                artist: {
                    id: faker.string.alpha({length: {min: 10, max: 20}}),
                    name: faker.string.alpha({length: {min: 10, max: 20}}),
                    link: faker.helpers.arrayElement([
                        faker.helpers.arrayElement([
                            faker.string.alpha({length: {min: 10, max: 20}}),
                            null,
                        ]),
                        undefined,
                    ]),
                },
                cover: faker.helpers.arrayElement([
                    faker.helpers.arrayElement([null]),
                    undefined,
                ]),
                year: faker.helpers.arrayElement([
                    faker.helpers.arrayElement([
                        faker.number.int({min: undefined, max: undefined}),
                        null,
                    ]),
                    undefined,
                ]),
                link: faker.helpers.arrayElement([
                    faker.helpers.arrayElement([
                        faker.string.alpha({length: {min: 10, max: 20}}),
                        null,
                    ]),
                    undefined,
                ]),
            },
            undefined,
        ]),
        cover: faker.helpers.arrayElement([
            faker.helpers.arrayElement([null]),
            undefined,
        ]),
        year: faker.helpers.arrayElement([
            faker.helpers.arrayElement([
                faker.number.int({min: undefined, max: undefined}),
                null,
            ]),
            undefined,
        ]),
        lyrics: faker.helpers.arrayElement([
            faker.helpers.arrayElement([
                faker.string.alpha({length: {min: 10, max: 20}}),
                null,
            ]),
            undefined,
        ]),
        explicit: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]),
        size: faker.helpers.arrayElement([
            faker.number.int({min: undefined, max: undefined}),
            undefined,
        ]),
        track: faker.helpers.arrayElement([
            faker.helpers.arrayElement([
                faker.number.int({min: undefined, max: undefined}),
                null,
            ]),
            undefined,
        ]),
        duration: faker.helpers.arrayElement([
            faker.helpers.fromRegExp("^-?(d+.)?d{2}:d{2}:d{2}(.d{1,7})?$"),
            undefined,
        ]),
        artists: Array.from(
            {length: faker.number.int({min: 1, max: 10})},
            (_, i) => i + 1,
        ).map(() => ({
            id: faker.string.alpha({length: {min: 10, max: 20}}),
            name: faker.string.alpha({length: {min: 10, max: 20}}),
            link: faker.helpers.arrayElement([
                faker.helpers.arrayElement([
                    faker.string.alpha({length: {min: 10, max: 20}}),
                    null,
                ]),
                undefined,
            ]),
        })),
        genres: Array.from(
            {length: faker.number.int({min: 1, max: 10})},
            (_, i) => i + 1,
        ).map(() => faker.string.alpha({length: {min: 10, max: 20}})),
        link: faker.helpers.arrayElement([
            faker.helpers.arrayElement([
                faker.string.alpha({length: {min: 10, max: 20}}),
                null,
            ]),
            undefined,
        ]),
        price: faker.helpers.arrayElement([
            faker.number.float({min: undefined, max: undefined, fractionDigits: 2}),
            undefined,
        ]),
    }));

export const getGetSongResponseMock = (
    overrideResponse: Partial<SourceSong> = {},
): SourceSong => ({
    id: faker.string.alpha({length: {min: 10, max: 20}}),
    title: faker.string.alpha({length: {min: 10, max: 20}}),
    album: faker.helpers.arrayElement([
        {
            id: faker.string.alpha({length: {min: 10, max: 20}}),
            name: faker.string.alpha({length: {min: 10, max: 20}}),
            artist: {
                id: faker.string.alpha({length: {min: 10, max: 20}}),
                name: faker.string.alpha({length: {min: 10, max: 20}}),
                link: faker.helpers.arrayElement([
                    faker.helpers.arrayElement([
                        faker.string.alpha({length: {min: 10, max: 20}}),
                        null,
                    ]),
                    undefined,
                ]),
            },
            cover: faker.helpers.arrayElement([
                faker.helpers.arrayElement([null]),
                undefined,
            ]),
            year: faker.helpers.arrayElement([
                faker.helpers.arrayElement([
                    faker.number.int({min: undefined, max: undefined}),
                    null,
                ]),
                undefined,
            ]),
            link: faker.helpers.arrayElement([
                faker.helpers.arrayElement([
                    faker.string.alpha({length: {min: 10, max: 20}}),
                    null,
                ]),
                undefined,
            ]),
        },
        undefined,
    ]),
    cover: faker.helpers.arrayElement([
        faker.helpers.arrayElement([null]),
        undefined,
    ]),
    year: faker.helpers.arrayElement([
        faker.helpers.arrayElement([
            faker.number.int({min: undefined, max: undefined}),
            null,
        ]),
        undefined,
    ]),
    lyrics: faker.helpers.arrayElement([
        faker.helpers.arrayElement([
            faker.string.alpha({length: {min: 10, max: 20}}),
            null,
        ]),
        undefined,
    ]),
    explicit: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]),
    size: faker.helpers.arrayElement([
        faker.number.int({min: undefined, max: undefined}),
        undefined,
    ]),
    track: faker.helpers.arrayElement([
        faker.helpers.arrayElement([
            faker.number.int({min: undefined, max: undefined}),
            null,
        ]),
        undefined,
    ]),
    duration: faker.helpers.arrayElement([
        faker.helpers.fromRegExp("^-?(d+.)?d{2}:d{2}:d{2}(.d{1,7})?$"),
        undefined,
    ]),
    artists: Array.from(
        {length: faker.number.int({min: 1, max: 10})},
        (_, i) => i + 1,
    ).map(() => ({
        id: faker.string.alpha({length: {min: 10, max: 20}}),
        name: faker.string.alpha({length: {min: 10, max: 20}}),
        link: faker.helpers.arrayElement([
            faker.helpers.arrayElement([
                faker.string.alpha({length: {min: 10, max: 20}}),
                null,
            ]),
            undefined,
        ]),
    })),
    genres: Array.from(
        {length: faker.number.int({min: 1, max: 10})},
        (_, i) => i + 1,
    ).map(() => faker.string.alpha({length: {min: 10, max: 20}})),
    link: faker.helpers.arrayElement([
        faker.helpers.arrayElement([
            faker.string.alpha({length: {min: 10, max: 20}}),
            null,
        ]),
        undefined,
    ]),
    price: faker.helpers.arrayElement([
        faker.number.float({min: undefined, max: undefined, fractionDigits: 2}),
        undefined,
    ]),
    ...overrideResponse,
});

export const getPurchaseSongResponseMock = (): Stream =>
    faker.string.alpha({length: {min: 10, max: 20}});

export const getSearchAlbumsResponseMock = (): SourceAlbum[] =>
    Array.from(
        {length: faker.number.int({min: 1, max: 10})},
        (_, i) => i + 1,
    ).map(() => ({
        id: faker.string.alpha({length: {min: 10, max: 20}}),
        name: faker.string.alpha({length: {min: 10, max: 20}}),
        artist: {
            id: faker.string.alpha({length: {min: 10, max: 20}}),
            name: faker.string.alpha({length: {min: 10, max: 20}}),
            link: faker.helpers.arrayElement([
                faker.helpers.arrayElement([
                    faker.string.alpha({length: {min: 10, max: 20}}),
                    null,
                ]),
                undefined,
            ]),
        },
        cover: faker.helpers.arrayElement([
            faker.helpers.arrayElement([null]),
            undefined,
        ]),
        year: faker.helpers.arrayElement([
            faker.helpers.arrayElement([
                faker.number.int({min: undefined, max: undefined}),
                null,
            ]),
            undefined,
        ]),
        songsCount: faker.helpers.arrayElement([
            faker.helpers.arrayElement([
                faker.number.int({min: undefined, max: undefined}),
                null,
            ]),
            undefined,
        ]),
        link: faker.helpers.arrayElement([
            faker.helpers.arrayElement([
                faker.string.alpha({length: {min: 10, max: 20}}),
                null,
            ]),
            undefined,
        ]),
    }));

export const getListSourcesMockHandler = (
    overrideResponse?:
        | ListSourcesResponse
        | ((
        info: Parameters<Parameters<typeof http.get>[1]>[0],
    ) => Promise<ListSourcesResponse> | ListSourcesResponse),
    options?: RequestHandlerOptions,
) => {
    return http.get(
        "*/sources",
        async (info) => {
            return new HttpResponse(
                overrideResponse !== undefined
                    ? typeof overrideResponse === "function"
                        ? await overrideResponse(info)
                        : overrideResponse
                    : getListSourcesResponseMock(),
                {status: 200, headers: {"Content-Type": "text/plain"}},
            );
        },
        options,
    );
};

export const getCreateSourceMockHandler = (
    overrideResponse?:
        | CreateSourceResponse
        | ((
        info: Parameters<Parameters<typeof http.post>[1]>[0],
    ) => Promise<CreateSourceResponse> | CreateSourceResponse),
    options?: RequestHandlerOptions,
) => {
    return http.post(
        "*/sources",
        async (info) => {
            return new HttpResponse(
                overrideResponse !== undefined
                    ? typeof overrideResponse === "function"
                        ? await overrideResponse(info)
                        : overrideResponse
                    : getCreateSourceResponseMock(),
                {status: 200, headers: {"Content-Type": "text/plain"}},
            );
        },
        options,
    );
};

export const getGetSourceMockHandler = (
    overrideResponse?:
        | GetSourceResponse
        | ((
        info: Parameters<Parameters<typeof http.get>[1]>[0],
    ) => Promise<GetSourceResponse> | GetSourceResponse),
    options?: RequestHandlerOptions,
) => {
    return http.get(
        "*/sources/:id",
        async (info) => {
            return new HttpResponse(
                overrideResponse !== undefined
                    ? typeof overrideResponse === "function"
                        ? await overrideResponse(info)
                        : overrideResponse
                    : getGetSourceResponseMock(),
                {status: 200, headers: {"Content-Type": "text/plain"}},
            );
        },
        options,
    );
};

export const getUpdateSourceMockHandler = (
    overrideResponse?:
        | UpdateSourceResponse
        | ((
        info: Parameters<Parameters<typeof http.put>[1]>[0],
    ) => Promise<UpdateSourceResponse> | UpdateSourceResponse),
    options?: RequestHandlerOptions,
) => {
    return http.put(
        "*/sources/:id",
        async (info) => {
            return new HttpResponse(
                overrideResponse !== undefined
                    ? typeof overrideResponse === "function"
                        ? await overrideResponse(info)
                        : overrideResponse
                    : getUpdateSourceResponseMock(),
                {status: 200, headers: {"Content-Type": "text/plain"}},
            );
        },
        options,
    );
};

export const getDeleteSourceMockHandler = (
    overrideResponse?:
        | DeleteSourceResponse
        | ((
        info: Parameters<Parameters<typeof http.delete>[1]>[0],
    ) => Promise<DeleteSourceResponse> | DeleteSourceResponse),
    options?: RequestHandlerOptions,
) => {
    return http.delete(
        "*/sources/:id",
        async (info) => {
            return new HttpResponse(
                overrideResponse !== undefined
                    ? typeof overrideResponse === "function"
                        ? await overrideResponse(info)
                        : overrideResponse
                    : getDeleteSourceResponseMock(),
                {status: 200, headers: {"Content-Type": "text/plain"}},
            );
        },
        options,
    );
};

export const getSearchSongsMockHandler = (
    overrideResponse?:
        | SourceSong[]
        | ((
        info: Parameters<Parameters<typeof http.get>[1]>[0],
    ) => Promise<SourceSong[]> | SourceSong[]),
    options?: RequestHandlerOptions,
) => {
    return http.get(
        "*/sources/:id/songs/search/:query",
        async (info) => {
            return new HttpResponse(
                overrideResponse !== undefined
                    ? typeof overrideResponse === "function"
                        ? await overrideResponse(info)
                        : overrideResponse
                    : getSearchSongsResponseMock(),
                {status: 200, headers: {"Content-Type": "text/plain"}},
            );
        },
        options,
    );
};

export const getGetSongMockHandler = (
    overrideResponse?:
        | SourceSong
        | ((
        info: Parameters<Parameters<typeof http.get>[1]>[0],
    ) => Promise<SourceSong> | SourceSong),
    options?: RequestHandlerOptions,
) => {
    return http.get(
        "*/sources/:id/songs/:songId",
        async (info) => {
            return new HttpResponse(
                overrideResponse !== undefined
                    ? typeof overrideResponse === "function"
                        ? await overrideResponse(info)
                        : overrideResponse
                    : getGetSongResponseMock(),
                {status: 200, headers: {"Content-Type": "text/plain"}},
            );
        },
        options,
    );
};

export const getPurchaseSongMockHandler = (
    overrideResponse?:
        | Stream
        | ((
        info: Parameters<Parameters<typeof http.get>[1]>[0],
    ) => Promise<Stream> | Stream),
    options?: RequestHandlerOptions,
) => {
    return http.get(
        "*/sources/:id/songs/purchase/:songId",
        async (info) => {
            return new HttpResponse(
                overrideResponse !== undefined
                    ? typeof overrideResponse === "function"
                        ? await overrideResponse(info)
                        : overrideResponse
                    : getPurchaseSongResponseMock(),
                {status: 200, headers: {"Content-Type": "text/plain"}},
            );
        },
        options,
    );
};

export const getSearchAlbumsMockHandler = (
    overrideResponse?:
        | SourceAlbum[]
        | ((
        info: Parameters<Parameters<typeof http.get>[1]>[0],
    ) => Promise<SourceAlbum[]> | SourceAlbum[]),
    options?: RequestHandlerOptions,
) => {
    return http.get(
        "*/sources/:id/albums/search/:query",
        async (info) => {
            return new HttpResponse(
                overrideResponse !== undefined
                    ? typeof overrideResponse === "function"
                        ? await overrideResponse(info)
                        : overrideResponse
                    : getSearchAlbumsResponseMock(),
                {status: 200, headers: {"Content-Type": "text/plain"}},
            );
        },
        options,
    );
};
export const getSourcesMock = () => [
    getListSourcesMockHandler(),
    getCreateSourceMockHandler(),
    getGetSourceMockHandler(),
    getUpdateSourceMockHandler(),
    getDeleteSourceMockHandler(),
    getSearchSongsMockHandler(),
    getGetSongMockHandler(),
    getPurchaseSongMockHandler(),
    getSearchAlbumsMockHandler(),
];
